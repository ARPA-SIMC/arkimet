#!/usr/bin/python3

import re
import configparser
import logging
import argparse
import datetime
import subprocess
import threading
import sys
import arkimet as arki
from arkimet.server import views
from werkzeug.exceptions import HTTPException, NotFound
from socketserver import ForkingMixIn
from http.server import HTTPServer, BaseHTTPRequestHandler
from setproctitle import setproctitle


class Server(ForkingMixIn, HTTPServer):
    def __init__(self, *args, **kw):
        super().__init__(*args, **kw)
        from werkzeug.routing import Map, Rule
        self.url = "http://{s.server_name}:{s.server_port}".format(s=self)
        self.url_map = Map([
            Rule('/', endpoint='ArkiIndex'),
            Rule('/config', endpoint='ArkiConfig'),
            Rule('/qexpand', endpoint='ArkiQExpand'),
            Rule('/aliases', endpoint='ArkiAliases'),
            Rule('/query', endpoint='arki_query'),
            Rule('/summary', endpoint='ArkiSummary'),
            Rule('/dataset/<name>', endpoint='ArkiDatasetIndex'),
            Rule('/dataset/<name>/query', endpoint='arki_dataset_query'),
            Rule('/dataset/<name>/summary', endpoint='ArkiDatasetSummary'),
            Rule('/dataset/<name>/config', endpoint='ArkiDatasetConfig'),
        ])

    def read_config(self, pathname):
        logging.info("Reading configuration from %s", pathname)
        self.cfg = configparser.ConfigParser()
        self.cfg.read(pathname)

        # Amend configuration turning local datasets into remote dataset
        self.remote_cfg = configparser.ConfigParser()
        for sec in self.cfg.sections():
            self.remote_cfg.add_section(sec)
            for k, v in self.cfg.items(sec):
                self.remote_cfg.set(sec, k, v)
            self.remote_cfg.set(sec, "path", self.url + "/dataset/" + sec);
            self.remote_cfg.set(sec, "type", "remote")
            self.remote_cfg.set(sec, "server", self.url)


class Handler(BaseHTTPRequestHandler):
    re_pathsplit = re.compile(r"/+")

    def make_environ(self):
        """
        Create an environment that can be used with werkzeug
        """
        # Derived from werkzeug's WSGIRequestHandler
        from werkzeug.urls import url_parse, url_unquote
        from werkzeug._compat import wsgi_encoding_dance

        request_url = url_parse(self.path)

        url_scheme = "http"
        path_info = url_unquote(request_url.path)

        environ = {
            'wsgi.version':         (1, 0),
            'wsgi.url_scheme':      url_scheme,
            'wsgi.input':           self.rfile,
            'wsgi.errors':          sys.stderr,
            'wsgi.multithread':     False,
            'wsgi.multiprocess':    True,
            'wsgi.run_once':        False,
            'SERVER_SOFTWARE':      self.server_version,
            'REQUEST_METHOD':       self.command,
            'SCRIPT_NAME':          '',
            'PATH_INFO':            wsgi_encoding_dance(path_info),
            'QUERY_STRING':         wsgi_encoding_dance(request_url.query),
            'CONTENT_TYPE':         self.headers.get('Content-Type', ''),
            'CONTENT_LENGTH':       self.headers.get('Content-Length', ''),
            'REMOTE_ADDR':          self.client_address[0],
            'REMOTE_PORT':          self.client_address[1],
            'SERVER_NAME':          self.server.server_address[0],
            'SERVER_PORT':          str(self.server.server_address[1]),
            'SERVER_PROTOCOL':      self.request_version
        }

        for key, value in self.headers.items():
            key = 'HTTP_' + key.upper().replace('-', '_')
            if key not in ('HTTP_CONTENT_TYPE', 'HTTP_CONTENT_LENGTH'):
                environ[key] = value

        if request_url.netloc:
            environ['HTTP_HOST'] = request_url.netloc

        return environ

    def log_request(self, code='-', size='-'):
        """
        Wrap BaseHTTPRequestHandler's send_response to add logging of the
        request
        """
        logging.info('%s - - [%s] "%s" %s %s',
                     self.client_address[0],
                     datetime.datetime.utcnow().strftime("%d/%b/%Y:%H:%M:%S +0000"),
                     self.requestline,
                     code, size, extra={"access_log": True})

    def dispatch(self):
        """
        Dispatch a request to the endpoint given by self.server.url_map
        """
        from werkzeug.wrappers import Request, Response
        request = Request(self.make_environ())
        setproctitle("arki-server {} for {}".format(request.base_url, request.remote_addr))
        adapter = self.server.url_map.bind_to_environ(request.environ)
        try:
            endpoint, values = adapter.match()
            meth = getattr(views, endpoint, None)
            if meth is None: raise NotFound("endpoint {} not found".format(endpoint))
            view = meth(request, self, **values)
            view.run()
        except HTTPException as e:
            self.send_response(e.code, e.description)
            for k, v in e.get_headers():
                self.send_header(k, v)
            self.end_headers()
            self.wfile.write(e.get_body(request.environ).encode("utf-8"))

    def do_GET(self):
        self.dispatch()

    def do_POST(self):
        self.dispatch()


def main():
    import argparse

    parser = argparse.ArgumentParser(
        description="Start the arkimet server, serving the datasets found in the configuration file")

    parser.add_argument("configfile", help="dataset configuration file")

    parser.add_argument('--version', action='version', version='%(prog)s 1.0')

    parser.add_argument("--host", "--hostname", metavar="host", default="", help="interface to listen to. Default: all interfaces")
    parser.add_argument("--port", "-p", metavar="port", type=int, default=8080, help="port to listen not. Default: 8080")
    parser.add_argument("--url", metavar="url", help="url to use to reach the server")

    parser.add_argument("--accesslog", metavar="file", help="file where to log normal access information")
    parser.add_argument("--perflog", metavar="file", help="file where to log query information and performance statistics")
    parser.add_argument("--errorlog", metavar="file", help="file where to log errors")
    parser.add_argument("--syslog", action="store_true", help="log to system log")
    parser.add_argument("--quiet", action="store_true", help="do not log to standard output")
    parser.add_argument("--verbose", action="store_true", help="verbose output")
    parser.add_argument("--debug", action="store_true", help="debug output")

    parser.add_argument("--runtest", metavar="cmd", help="start the server, run the given test command and return its exit status")

#        inbound = add<StringOption>("inbound", 0, "inbound", "dir",
#                "directory where files to import are found."
#                " If specified, it enables a way of triggering uploads"
#                " remotely: files found in the inbound directory can be"
#                " remotely scanned or imported");

    args = parser.parse_args()

    root_logger = logging.getLogger()

    if args.debug:
        root_logger.setLevel(logging.DEBUG)
    else:
        root_logger.setLevel(logging.INFO)

    if not args.quiet:
        h = logging.StreamHandler()
        h.setFormatter(logging.Formatter("%(asctime)-15s %(levelname)s %(message)s"))
        if args.debug:
            h.setLevel(logging.DEBUG)
        elif args.verbose:
            h.setLevel(logging.INFO)
        else:
            h.setLevel(logging.WARN)
        class Filter:
            def filter(self, record):
                return getattr(record, "perf", None) is None
        h.addFilter(Filter())
        root_logger.addHandler(h)

    if args.accesslog:
        from logging.handlers import WatchedFileHandler
        h = WatchedFileHandler(args.accesslog)
        h.setFormatter(logging.Formatter("%(asctime)-15s %(levelname)s %(message)s"))
        h.setLevel(logging.INFO)
        class Filter:
            def filter(self, record):
                if not getattr(record, "access_log", False): return False
                return record.levelno < logging.WARN
        h.addFilter(Filter())
        root_logger.addHandler(h)

    if args.perflog:
        from logging.handlers import WatchedFileHandler
        h = WatchedFileHandler(args.perflog)
        class PerfFormatter(logging.Formatter):
            def format(self, record):
                import json
                info = getattr(record, "perf", None)
                return json.dumps(info)
        h.setFormatter(PerfFormatter())
        h.setLevel(logging.INFO)
        class Filter:
            def filter(self, record):
                return getattr(record, "perf", None) is not None
        h.addFilter(Filter())
        root_logger.addHandler(h)

    if args.errorlog:
        from logging.handlers import WatchedFileHandler
        h = WatchedFileHandler(args.errorlog)
        h.setFormatter(logging.Formatter("%(asctime)-15s %(levelname)s %(message)s"))
        h.setLevel(logging.WARN)
        root_logger.addHandler(h)

    if args.syslog:
        h = logging.SyslogHandler()
        h.setFormatter(logging.Formatter("%(asctime)-15s %(levelname)s %(message)s"))
        root_logger.addHandler(h)

    httpd = Server((args.host, args.port), Handler)
    if args.url:
        httpd.url = args.url
    httpd.read_config(args.configfile)

    if args.runtest:
        exit_code = 0
        class TestThread(threading.Thread):
            def run(self):
                try:
                    subprocess.check_call(args.runtest, shell=True)
                except:
                    exit_code = 1
                httpd.shutdown()
        test_thread = TestThread()
        test_thread.start()
        httpd.serve_forever()
        test_thread.join()
        sys.exit(exit_code)
    else:
        httpd.serve_forever()


if __name__ == "__main__":
    main()
