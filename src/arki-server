#!/usr/bin/env python

# arki-server - Web front-end to arki-query
#
# Copyright (C) 2007--2010  ARPA-SIM <urpsim@smr.arpa.emr.it>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
# Author: Enrico Zini <enrico@enricozini.com>

VERSION="0.16"

ARKI_QUERY="arki-query"
ARKI_DUMP="arki-dump"

from arkimet import bottle
from arkimet.bottle import route, post
import subprocess
import logging
import logging.handlers
import os, os.path, signal, errno, sys, time, select
import tempfile, shutil
import urllib, urlparse
from cStringIO import StringIO

#
# Server configuration
#

server = None
dsconfig = None

# bottle.debug(True)

#
# Logging functions
#

def log_access(fmt, *args):
    logging.info(fmt, *args)
def log_error(fmt, *args):
    logging.warning(fmt, *args)

class TextHTTPError(bottle.HTTPResponse):
    """ Used to generate an error page """
    def __init__(self, code=500, output='Unknown Error', header=None):
        super(TextHTTPError, self).__init__(output, code, header)

    def __repr__(self):
        return output

#
# arki-* running infrastructure
#

class ScriptFile(object):
    def __init__(self, fd, closefunc=None):
        self.__orig = fd
        self.__closefunc = closefunc
    def read(self, *args):
        return self.__orig.read(*args)
    def __iter__(self):
        return self.__orig.__iter__()
    def __next__(self):
        return self.__orig.__next__()
    def close(self):
        if self.__closefunc: self.__closefunc()
        self.__orig.close()

class Script(object):
    def __init__(self, owndir=False, fields=None):
        if owndir:
            self.subdir = tempfile.mkdtemp()
        else:
            self.subdir = None
        self.args = []
        self.fname = "arkimet"
        self.ext = "bin"
        self.content_type = "application/octet-stream"
        self.proc = None
        self.fields = fields if fields else {}
        self.dsconf = None

    def read(self):
        """
        Run the script and return a tuple (return code, stdout, stderr)
        """
        log_access("Running %s", repr(self.args));
        self.proc = subprocess.Popen(self.args, stdin=open("/dev/null", "r"),
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                close_fds=True)
        stdout, stderr = self.proc.communicate()
        res = self.proc.wait()
        if res != 0:
            log_error("%s exited with error code %d and stderr %s", repr(self.args), res, repr(stderr));
        if self.subdir:
            shutil.rmtree(self.subdir)
        return res, stdout, stderr

    def stream(self):
        """
        Run the script and return a file-like object that can be used to read
        its standard output. The file-like object can, for example, be passed
        to wsgi.file_wrapper.
        """
        bottle.response.content_type = self.content_type
        if getattr(self, "dsconf", None) and not self.content_type.startswith("text/"):
            bottle.response.headerlist.append(("Content-Disposition", "attachment; filename=%s.%s" % (self.fname, self.ext)))
        log_access("Running %s", repr(self.args));
        tmpstderr = tempfile.TemporaryFile()
        self.proc = subprocess.Popen(self.args, stdin=open("/dev/null", "r"),
                stdout=subprocess.PIPE,
                stderr=tmpstderr,
                close_fds=True)

        # Wait until data becomes available
        p = select.poll()
        p.register(self.proc.stdout.fileno())
        events = p.poll()
        for fd, val in events:
            if fd != self.proc.stdout.fileno(): continue
            # Did the command exit with error without producing any data on stdout?
            if (val & select.POLLIN == 0 and val & select.POLLHUP != 0):
                res = self.proc.wait()
                tmpstderr.seek(0)
                stderr = tmpstderr.read()
                if res != 0:
                    if self.subdir:
                        shutil.rmtree(self.subdir)
                    raise TextHTTPError(code=500, output=(stderr if stderr else "arki-query exited with code %d" % res))

        def on_close():
            res = self.proc.poll()
            if res is None:
                # If the process is still running, kill it
                log_error("%s is still running after sending the output: terminating it", repr(self.args));
                os.kill(self.proc.pid, signal.SIGTERM)
                res = self.proc.wait()
            if res != 0:
                tmpstderr.seek(0)
                stderr = tmpstderr.read()
                log_error("%s exited with error code %d and stderr %s", repr(self.args), res, repr(stderr));

            if self.subdir:
                shutil.rmtree(self.subdir)
        return ScriptFile(self.proc.stdout, on_close)

class ArkiDump(Script):
    def __init__(self, *args, **kw):
        super(ArkiDump, self).__init__(**kw)
        self.args = (ARKI_DUMP,) + args
        self.content_type = "text/plain"

class ArkiQueryBase(Script):
    def __init__(self, dsconf=None, **kw):
        super(ArkiQueryBase, self).__init__(**kw)
        self.dsconf = dsconf
        self.args = [ARKI_QUERY]
        if self.dsconf:
            self.fname = self.dsconf["name"]
        self.do_qmacro = "qmacro" in self.fields
        if self.do_qmacro:
            self.args.append("--qmacro=" + self.fields["qmacro"].strip())
            self.fname = self.fields["qmacro"]
            qfname = os.path.join(self.subdir, "query")
            fd = open(qfname, "w")
            fd.write(self.fields.get("query", "").strip())
            fd.flush()
            fd.close()
            self.args.append("--file=" + qfname)
            if self.dsconf is None:
                self.args.append("--config=" + server.configfile)
            else:
                self.args.append("--config=" + self.dsconf["path"])

class ArkiQuery(ArkiQueryBase):
    def __init__(self, **kw):
        super(ArkiQuery, self).__init__(**kw)
        style = self.fields.get("style", "metadata").strip()
        if style == "metadata":
            pass
        elif style == "yaml":
            self.args.append("--yaml")
            self.content_type = "text/x-yaml"
            self.ext = "yaml"
        elif style == "inline":
            self.args.append("--inline")
            self.ext = "bin"
        elif style == "data":
            self.args.append("--data")
            self.ext = "bin"
        elif style == "postprocess":
            self.args.append("--postproc=" + self.fields.get("command", ""))
            for f in self.fields.getall("postprocfile"):
                if not self.subdir: raise RuntimeError, "posprocess data have been provided but arki-query is not run in a subdir"
                # Store the uploaded file in the temporary directory
                dest = os.path.join(self.subdir, os.path.basename(f.filename))
                destfd = open(dest, "w")
                shutil.copyfileobj(f.file, destfd)
                destfd.close()
                # Pass it to arki-query
                self.args.append("--postproc-data=" + dest)
            self.ext = "bin"
        elif style == "rep_metadata":
            self.args.append("--report=" + self.fields.get("command", ""))
            self.content_type = "text/plain"
            self.ext = "txt"
        elif style == "rep_summary":
            self.args.append("--summary")
            self.args.append("--report=" + self.fields.get("command", ""))
            self.content_type = "text/plain"
            self.ext = "txt"
        if "sort" in self.fields:
            self.args.append("--sort=" + self.fields["sort"]);

        if not self.do_qmacro:
            self.args.append(self.fields.get("query", "").strip())
            self.args.append(self.dsconf['path'])

class ArkiQuerySummary(ArkiQueryBase):
    def __init__(self, **kw):
        super(ArkiQuerySummary, self).__init__(**kw)
        self.args.append('--summary')
        style = self.fields.get("style", "summary").strip()
        if style == "yaml":
            self.args.append("--yaml")
            self.content_type = "text/x-yaml"
            self.ext = "yaml"
        if not self.do_qmacro:
            self.args.append(self.fields.get("query", "").strip())
            self.args.append(self.dsconf['path'])


#
# Server machinery
#

class Args(object):
    """
    Access parameters from GET or POST
    """
    def __contains__(self, key):
        return key in bottle.request.GET or key in bottle.request.POST
    def __getitem__(self, key):
        return bottle.request.GET.get(key, bottle.request.POST.get(key))
    def get(self, key, default):
        return bottle.request.GET.get(key, bottle.request.POST.get(key, default))
    def getall(self, key):
        return bottle.request.GET.getall(key) + bottle.request.POST.getall(key)
    def has_key(self, key):
        return key in bottle.request.GET or key in bottle.request.POST
    def keys(self):
        res = set(bottle.request.GET.keys())
        res.update(bottle.request.POST.keys())
        return list(res)

class Server(object):
    def __init__(self, configfile, opts = None):
        self.configfile = configfile
        self.port = 80
        self.url = None

        if opts:
            if opts.port != None: self.port = opts.port
            if opts.url != None: self.url = opts.url

        # Create url if not provided
        if self.url == None:
            if self.port == 443:
                self.url = "https://localhost"
            else:
                self.url = "http://localhost"
                if self.port != 80:
                    self.url += ":" + str(self.port)

        # Get the interface name or extract it from the URL
        if opts.host:
            self.host = opts.host
        else:
            self.host = urlparse.urlparse(self.url).hostname

        # Prepare the configuration amended with urls pointing to us
        self.configdict = dsconfig.dict()
        for s in dsconfig.sections:
            self.configdict[s]['path'] = self.url + "/dataset/" + s
            self.configdict[s]['type'] = 'remote'
            self.configdict[s]['server'] = self.url
        amended = ConfigObj(list_values = False)
        amended.update(self.configdict)
        out = StringIO()
        amended.write(out)
        self.configbuf = out.getvalue()




@route("/")
@post("/")
def index():
    """
    Show a list of all available datasets
    """
    res = """<html><body>
    Available datasets:
    <ul>
    """
    for dsname in dsconfig.sections:
        res += "<li><a href='/dataset/%s'>%s</a></li>\n" % (dsname, dsname)
    res += """</ul>
    <a href="/query">Perform a query</a>
    </body></html>
    """
    return res

@route("/config")
@route("/config/")
@post("/config")
@post("/config/")
def config():
    """
    Return the configuration
    """
    args = Args()
    if "json" in args:
        return server.configdict
    else:
        bottle.response.content_type = "text/plain"
        return server.configbuf

@route("/aliases")
@route("/aliases/")
@post("/aliases")
@post("/aliases/")
def aliases():
    """
    Dump the alias database
    """
    return ArkiDump("--aliases").stream()

@route("/qexpand")
@route("/qexpand/")
@post("/qexpand")
@post("/qexpand/")
def qexpand():
    """
    Expand a query
    """
    args = Args()
    query = args.get("query", "").strip()
    return ArkiDump("--query", query).stream()

@route("/query")
@route("/query/")
@post("/query")
@post("/query/")
def query():
    """
    Download the results of a query
    """
    args = Args()
    if not "qmacro" in args:
        raise bottle.HTTPError(400, "Root-level query withouth qmacro argument")
    return ArkiQuery(owndir = True, fields=args).stream()

@route("/summary")
@route("/summary/")
@post("/summary")
@post("/summary/")
def summary():
    """
    Download the summary of a dataset
    """
    args = Args()
    if not "qmacro" in args:
        raise bottle.HTTPError(400, "Root-level query withouth qmacro argument")
    return ArkiQuerySummary(owndir = True, fields=args).stream()

@route("/dataset/:name")
@route("/dataset/:name/")
@post("/dataset/:name")
@post("/dataset/:name/")
def dataset_index(name):
    """
    Show the summary of a dataset
    """
    conf = dsconfig.get(name, None)
    if conf is None:
        raise bottle.HTTPError(code=404, output='dataset %s not found' % name)
    res, summary, stderr = ArkiQuerySummary(dsconf=conf, fields=dict(style="yaml")).read()
    return """<html>
<head><title>Dataset %s</title></head>
<body>
<ul>
<li><a href='/'>All datasets</a></li>
<li><a href='queryform'>Query</a></li>
<li><a href='summary'>Download summary</a></li>
</ul>
Summary of dataset <b>%s</b>:
<pre>
%s
</pre>
</body>
</html>""" % (name, name, summary)

@route("/dataset/:name/queryform")
@route("/dataset/:name/queryform/")
@post("/dataset/:name/queryform")
@post("/dataset/:name/queryform/")
def dataset_queryform(name):
    """
    Show a form to query the datasets
    """
    if not name in dsconfig:
        raise bottle.HTTPError(code=404, output='dataset %s not found' % name)
    return """<html>
<head><title>Query dataset %s</title></head>
<body>
  Please type or paste your query and press submit:
  <form action="query" method="push">
    <textarea name="query" cols="80" rows="15">
    </textarea>
    <br/>
    <select name="style">
      <option value="data">Data</option>
      <option value="yaml">Human-readable metadata</option>
      <option value="inline">Binary metadata and data</option>
      <option value="md">Binary metadata</option>
    </select>
    <br/>
    <input type="submit">
  </form>
</body>
</html>
""" % name

@route("/dataset/:name/config")
@route("/dataset/:name/config/")
@post("/dataset/:name/config")
@post("/dataset/:name/config/")
def dataset_config(name):
    """
    Return the dataset configuration
    """
    conf = dsconfig.get(name, None)
    if conf is None:
        raise bottle.HTTPError(code=404, output='dataset %s not found' % name)

    c = conf.dict()
    c['path'] = server.url + "/dataset/" + name
    c['type'] = 'remote'
    c['server'] = server.url

    args = Args()
    if "json" in args:
        return c
    else:
        amended = ConfigObj(list_values = False)
        amended[name] = {}
        amended[name].update(c)
        out = StringIO()
        amended.write(out)
        bottle.response.content_type = "text/plain"
        return out.getvalue()

@route("/dataset/:name/summary")
@route("/dataset/:name/summary/")
@post("/dataset/:name/summary")
@post("/dataset/:name/summary/")
def dataset_summary(name):
    """
    Download the summary of a dataset
    """
    conf = dsconfig.get(name, None)
    if conf is None:
        raise bottle.HTTPError(code=404, output='dataset %s not found' % name)
    return ArkiQuerySummary(dsconf=conf, fields=Args()).stream()

@route("/dataset/:name/query")
@route("/dataset/:name/query/")
@post("/dataset/:name/query")
@post("/dataset/:name/query/")
def dataset_query(name):
    """
    Download the summary of a dataset
    """
    conf = dsconfig.get(name, None)
    if conf is None:
        raise bottle.HTTPError(code=404, output='dataset %s not found' % name)
    return ArkiQuery(owndir = True, dsconf=conf, fields=Args()).stream()


#
# Application set up
#

class AccessLogFilter(logging.Filter):
    def filter(self, rec):
        if rec.levelno < logging.WARNING:
            return 1
        return 0

def setup_logging(opts):
    minlevel = logging.ERROR
    if opts.errorlog:
        minlevel = logging.WARNING
    if opts.accesslog:
        minlevel = logging.INFO
    if not opts.errorlog and not opts.accesslog and not opts.quiet:
        minlevel = logging.DEBUG
        logging.getLogger("").addHandler(logging.StreamHandler())

    logging.getLogger("").setLevel(minlevel)

    if opts.accesslog:
        accesslog = logging.handlers.TimedRotatingFileHandler(opts.accesslog, "D", 1, backupCount = 14)
        accesslog.setLevel(logging.INFO)
        accesslog.addFilter(AccessLogFilter())
        logging.getLogger("").addHandler(accesslog)

    if opts.errorlog:
        errorlog = logging.handlers.TimedRotatingFileHandler(opts.errorlog, "D", 1, backupCount = 14)
        errorlog.setLevel(logging.WARNING)
        logging.getLogger("").addHandler(errorlog)

def start_server(opts):
    args = dict(host=server.host, port=server.port)
    if opts.quiet: args["quiet"] = True
    if opts.runtest: args["server"] = bottle.WSGIRefServer
    bottle.run(**args)


if __name__ == "__main__":
    from optparse import OptionParser
    import sys

    class Parser(OptionParser):
        def error(self, msg):
            sys.stderr.write("%s: error: %s\n\n" % (self.get_prog_name(), msg))
            self.print_help(sys.stderr)
            sys.exit(2)

    parser = Parser(usage="usage: %prog configfile [options]",
                    version="%prog "+ VERSION,
                    description="Start the arkimet server, serving the datasets found in the configuration file")
    parser.add_option("--host", type="str", help="interface to listen to.  Default: localhost")
    parser.add_option("-p", "--port", type="int", help="port to listen to.  Default: %default")
    parser.add_option("--url", type="str", help="url to use to reach the server")
    parser.add_option("--runtest", type="str", help="start the server, run the given test command and return its exit status")
    parser.add_option("--accesslog", type="str", help="file where to log normal access information")
    parser.add_option("--errorlog", type="str", help="file where to log errors")
    parser.add_option("--quiet", action="store_true", help="do not log to standard output")
    parser.set_defaults(port = 8080)

    (opts, args) = parser.parse_args()

    setup_logging(opts)

    # Read configuration
    from configobj import ConfigObj
    if len(args) == 0:
        print >>sys.stderr, "Usage:", sys.argv[0], "config"
        parser.print_help(sys.stderr)
        sys.exit(1)
    dsconfig = ConfigObj(args[0], list_values = False)
    server = Server(args[0], opts)

    if opts.runtest:
        pid = os.fork()
        if not pid:
            # Child process, run server
            start_server(opts)
            sys.exit(0)
        # Parent process
        started = False
        for i in xrange(20):
            try:
                o = urllib.urlopen(server.url)
                o.close()
                started = True
                break
            except:
                rpid, rres = os.waitpid(pid, os.WNOHANG)
                if rpid == pid:
                    print >>sys.stderr, "Server stopped prematurely with exit code %d" % rres
                    sys.exit(1)
                time.sleep(0.2)
        if not started:
            print >>sys.stderr, "Server not started after 2 seconds"
            sys.exit(1)
        res = subprocess.call(opts.runtest, shell=True)
        os.kill(pid, signal.SIGINT)
        os.waitpid(pid, 0)
        sys.exit(res)
    else:
        start_server(opts)
