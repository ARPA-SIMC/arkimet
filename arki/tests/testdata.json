[
 {
  "doc": "",
  "group": "arki_tests",
  "method": "basic"
 },
 {
  "doc": "",
  "group": "arki_core_time",
  "method": "now"
 },
 {
  "doc": "",
  "group": "arki_core_time",
  "method": "compare"
 },
 {
  "doc": "",
  "group": "arki_core_time",
  "method": "arbitrary"
 },
 {
  "doc": "",
  "group": "arki_core_time",
  "method": "generate"
 },
 {
  "doc": "",
  "group": "arki_core_time",
  "method": "range_overlaps"
 },
 {
  "doc": "",
  "group": "arki_core_time",
  "method": "to_unix"
 },
 {
  "doc": "",
  "group": "arki_core_time",
  "method": "regression1"
 },
 {
  "doc": "",
  "group": "arki_core_time",
  "method": "lua"
 },
 {
  "doc": "",
  "group": "arki_file",
  "method": "linereader"
 },
 {
  "doc": "",
  "group": "arki_utils",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_utils_accounting",
  "method": "counter"
 },
 {
  "doc": "",
  "group": "arki_utils_gzip",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_utils_gzip",
  "method": "read_all"
 },
 {
  "doc": "",
  "group": "arki_utils_yaml",
  "method": "parse"
 },
 {
  "doc": "",
  "group": "arki_utils_yaml",
  "method": "comments"
 },
 {
  "doc": "",
  "group": "arki_utils_tar",
  "method": "size_with_length"
 },
 {
  "doc": "",
  "group": "arki_utils_tar",
  "method": "plain"
 },
 {
  "doc": "",
  "group": "arki_utils_tar",
  "method": "pax"
 },
 {
  "doc": "",
  "group": "arki_utils_zip",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_utils_files",
  "method": "dontpack"
 },
 {
  "doc": "",
  "group": "arki_utils_files",
  "method": "resolve_path"
 },
 {
  "doc": "",
  "group": "arki_utils_process",
  "method": "true"
 },
 {
  "doc": "",
  "group": "arki_utils_process",
  "method": "false"
 },
 {
  "doc": "",
  "group": "arki_utils_process",
  "method": "devnull"
 },
 {
  "doc": "",
  "group": "arki_utils_process",
  "method": "cat"
 },
 {
  "doc": "",
  "group": "arki_utils_process",
  "method": "cat_to_stderr"
 },
 {
  "doc": "",
  "group": "arki_utils_process",
  "method": "tee_to_stderr"
 },
 {
  "doc": "",
  "group": "arki_utils_process",
  "method": "ignore_stdin_write_stdout"
 },
 {
  "doc": "",
  "group": "arki_utils_process",
  "method": "ignore_stdin_write_stderr"
 },
 {
  "doc": "",
  "group": "arki_utils_process",
  "method": "cat_then_fail"
 },
 {
  "doc": "",
  "group": "arki_utils_regexp",
  "method": "basic_match"
 },
 {
  "doc": "",
  "group": "arki_utils_regexp",
  "method": "extended_match"
 },
 {
  "doc": "",
  "group": "arki_utils_regexp",
  "method": "capture"
 },
 {
  "doc": "",
  "group": "arki_utils_regexp",
  "method": "tokenize"
 },
 {
  "doc": "",
  "group": "arki_utils_regexp",
  "method": "splitter"
 },
 {
  "doc": "",
  "group": "arki_utils_regexp",
  "method": "splitter_empty"
 },
 {
  "doc": "",
  "group": "arki_utils_geos",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_binary",
  "method": "integer"
 },
 {
  "doc": "",
  "group": "arki_binary",
  "method": "varints"
 },
 {
  "doc": "",
  "group": "arki_binary",
  "method": "strings"
 },
 {
  "doc": "",
  "group": "arki_binary",
  "method": "cstrings"
 },
 {
  "doc": "",
  "group": "arki_binary",
  "method": "lines"
 },
 {
  "doc": "",
  "group": "arki_configfile",
  "method": "parse"
 },
 {
  "doc": "",
  "group": "arki_transaction",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_emitter_memory",
  "method": "null"
 },
 {
  "doc": "",
  "group": "arki_emitter_memory",
  "method": "bool"
 },
 {
  "doc": "",
  "group": "arki_emitter_memory",
  "method": "int"
 },
 {
  "doc": "",
  "group": "arki_emitter_memory",
  "method": "double"
 },
 {
  "doc": "",
  "group": "arki_emitter_memory",
  "method": "string"
 },
 {
  "doc": "",
  "group": "arki_emitter_memory",
  "method": "list"
 },
 {
  "doc": "",
  "group": "arki_emitter_memory",
  "method": "mapping"
 },
 {
  "doc": "",
  "group": "arki_emitter_json",
  "method": "null"
 },
 {
  "doc": "",
  "group": "arki_emitter_json",
  "method": "bool"
 },
 {
  "doc": "",
  "group": "arki_emitter_json",
  "method": "int"
 },
 {
  "doc": "",
  "group": "arki_emitter_json",
  "method": "double"
 },
 {
  "doc": "",
  "group": "arki_emitter_json",
  "method": "string"
 },
 {
  "doc": "",
  "group": "arki_emitter_json",
  "method": "list"
 },
 {
  "doc": "",
  "group": "arki_emitter_json",
  "method": "mapping"
 },
 {
  "doc": "",
  "group": "arki_values",
  "method": "comparison"
 },
 {
  "doc": "",
  "group": "arki_values",
  "method": "encoding"
 },
 {
  "doc": "",
  "group": "arki_values",
  "method": "valuebag"
 },
 {
  "doc": "",
  "group": "arki_values",
  "method": "regression1"
 },
 {
  "doc": "",
  "group": "arki_types",
  "method": "cast"
 },
 {
  "doc": "",
  "group": "arki_types",
  "method": "assign"
 },
 {
  "doc": "",
  "group": "arki_types",
  "method": "copy"
 },
 {
  "doc": "",
  "group": "arki_types",
  "method": "uitem"
 },
 {
  "doc": "",
  "group": "arki_types",
  "method": "assign1"
 },
 {
  "doc": "",
  "group": "arki_types_utils",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_types_source",
  "method": "blob"
 },
 {
  "doc": "",
  "group": "arki_types_source",
  "method": "inline"
 },
 {
  "doc": "",
  "group": "arki_types_source",
  "method": "url"
 },
 {
  "doc": "",
  "group": "arki_types_source",
  "method": "blob_details"
 },
 {
  "doc": "",
  "group": "arki_types_source",
  "method": "blob_bigfiles"
 },
 {
  "doc": "",
  "group": "arki_types_source",
  "method": "blob_pathnames"
 },
 {
  "doc": "",
  "group": "arki_types_source",
  "method": "blob_pathnames_encode"
 },
 {
  "doc": "",
  "group": "arki_types_source",
  "method": "blob_stream"
 },
 {
  "doc": "",
  "group": "arki_types_source",
  "method": "url_details"
 },
 {
  "doc": "",
  "group": "arki_types_source",
  "method": "inline_details"
 },
 {
  "doc": "",
  "group": "arki_types_reftime",
  "method": "position"
 },
 {
  "doc": "",
  "group": "arki_types_reftime",
  "method": "period"
 },
 {
  "doc": "",
  "group": "arki_types_reftime",
  "method": "position_details"
 },
 {
  "doc": "",
  "group": "arki_types_reftime",
  "method": "period_details"
 },
 {
  "doc": "",
  "group": "arki_types_reftime",
  "method": "range"
 },
 {
  "doc": "",
  "group": "arki_types_reftime",
  "method": "regression1"
 },
 {
  "doc": "",
  "group": "arki_types_reftime",
  "method": "lua"
 },
 {
  "doc": "",
  "group": "arki_types_origin",
  "method": "grib1"
 },
 {
  "doc": "",
  "group": "arki_types_origin",
  "method": "grib1_details"
 },
 {
  "doc": "",
  "group": "arki_types_origin",
  "method": "grib2"
 },
 {
  "doc": "",
  "group": "arki_types_origin",
  "method": "grib2_details"
 },
 {
  "doc": "",
  "group": "arki_types_origin",
  "method": "bufr"
 },
 {
  "doc": "",
  "group": "arki_types_origin",
  "method": "bufr_details"
 },
 {
  "doc": "",
  "group": "arki_types_origin",
  "method": "odimh5"
 },
 {
  "doc": "",
  "group": "arki_types_origin",
  "method": "odimh5_empty"
 },
 {
  "doc": "",
  "group": "arki_types_origin",
  "method": "odim_details"
 },
 {
  "doc": "",
  "group": "arki_types_origin",
  "method": "lua"
 },
 {
  "doc": "",
  "group": "arki_types_product",
  "method": "grib1"
 },
 {
  "doc": "",
  "group": "arki_types_product",
  "method": "grib1_details"
 },
 {
  "doc": "",
  "group": "arki_types_product",
  "method": "grib2"
 },
 {
  "doc": "",
  "group": "arki_types_product",
  "method": "grib2_table"
 },
 {
  "doc": "",
  "group": "arki_types_product",
  "method": "grib2_local_table"
 },
 {
  "doc": "",
  "group": "arki_types_product",
  "method": "grib2_details"
 },
 {
  "doc": "",
  "group": "arki_types_product",
  "method": "bufr"
 },
 {
  "doc": "",
  "group": "arki_types_product",
  "method": "bufr_details"
 },
 {
  "doc": "",
  "group": "arki_types_product",
  "method": "vm2"
 },
 {
  "doc": "",
  "group": "arki_types_product",
  "method": "vm2_details"
 },
 {
  "doc": "",
  "group": "arki_types_product",
  "method": "lua_grib1"
 },
 {
  "doc": "",
  "group": "arki_types_product",
  "method": "lua_grib2_constructor"
 },
 {
  "doc": "",
  "group": "arki_types_level",
  "method": "grib1_ltype"
 },
 {
  "doc": "",
  "group": "arki_types_level",
  "method": "grib1_l1"
 },
 {
  "doc": "",
  "group": "arki_types_level",
  "method": "grib1_l1large"
 },
 {
  "doc": "",
  "group": "arki_types_level",
  "method": "grib1_l1_l2"
 },
 {
  "doc": "",
  "group": "arki_types_level",
  "method": "grib1_details"
 },
 {
  "doc": "",
  "group": "arki_types_level",
  "method": "grib2s"
 },
 {
  "doc": "",
  "group": "arki_types_level",
  "method": "grib2s_missing"
 },
 {
  "doc": "",
  "group": "arki_types_level",
  "method": "grib2s_details"
 },
 {
  "doc": "",
  "group": "arki_types_level",
  "method": "grib2d"
 },
 {
  "doc": "",
  "group": "arki_types_level",
  "method": "grib2d_missing"
 },
 {
  "doc": "",
  "group": "arki_types_level",
  "method": "grib2d_details"
 },
 {
  "doc": "",
  "group": "arki_types_level",
  "method": "odimh5"
 },
 {
  "doc": "",
  "group": "arki_types_level",
  "method": "odimh5_details"
 },
 {
  "doc": "",
  "group": "arki_types_level",
  "method": "lua"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "grib1_seconds"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "grib1_hours"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "grib1_years"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "grib1_unknown"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "grib2_seconds"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "grib2_hours"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "grib2_years"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "grib2_negative"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "grib2_unknown"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "timedef_step_stat"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "timedef_step_stat_months"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "timedef_step"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "timedef_step_months"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "timedef_step_ptype"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "timedef_step_months_ptype"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "timedef_step_stats_secs_months"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "bufr"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "grib1_details"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "grib2_details"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "timedef_details"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "timedef_details"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "timedef_info"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "timedef_validity_time_to_emission_time"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "restrict_unit"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "enlarge_unit"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "compare_units"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "make_same_units"
 },
 {
  "doc": "",
  "group": "arki_types_timerange",
  "method": "lua"
 },
 {
  "doc": "",
  "group": "arki_types_area",
  "method": "grib"
 },
 {
  "doc": "",
  "group": "arki_types_area",
  "method": "grib_1"
 },
 {
  "doc": "",
  "group": "arki_types_area",
  "method": "odimh5"
 },
 {
  "doc": "",
  "group": "arki_types_area",
  "method": "vm2"
 },
 {
  "doc": "",
  "group": "arki_types_area",
  "method": "vm2_derived"
 },
 {
  "doc": "",
  "group": "arki_types_area",
  "method": "lua"
 },
 {
  "doc": "",
  "group": "arki_types_proddef",
  "method": "grib"
 },
 {
  "doc": "",
  "group": "arki_types_proddef",
  "method": "grib_1"
 },
 {
  "doc": "",
  "group": "arki_types_proddef",
  "method": "lua"
 },
 {
  "doc": "",
  "group": "arki_types_note",
  "method": "note"
 },
 {
  "doc": "",
  "group": "arki_types_note",
  "method": "lua"
 },
 {
  "doc": "",
  "group": "arki_types_assigneddataset",
  "method": "assigneddataset"
 },
 {
  "doc": "",
  "group": "arki_types_assigneddataset",
  "method": "lua"
 },
 {
  "doc": "",
  "group": "arki_types_bbox",
  "method": "invalid"
 },
 {
  "doc": "",
  "group": "arki_types_bbox",
  "method": "lua"
 },
 {
  "doc": "",
  "group": "arki_types_run",
  "method": "minute"
 },
 {
  "doc": "",
  "group": "arki_types_run",
  "method": "lua"
 },
 {
  "doc": "",
  "group": "arki_types_task",
  "method": "task"
 },
 {
  "doc": "",
  "group": "arki_types_task",
  "method": "lua"
 },
 {
  "doc": "",
  "group": "arki_types_quantity",
  "method": "quantity"
 },
 {
  "doc": "",
  "group": "arki_types_value",
  "method": "text"
 },
 {
  "doc": "",
  "group": "arki_types_value",
  "method": "binary"
 },
 {
  "doc": "",
  "group": "arki_types_value",
  "method": "zeroes"
 },
 {
  "doc": "",
  "group": "arki_types_typevector",
  "method": "misc"
 },
 {
  "doc": "",
  "group": "arki_types_typeset",
  "method": "typeset"
 },
 {
  "doc": "",
  "group": "arki_itemset",
  "method": "basic_ops"
 },
 {
  "doc": "",
  "group": "arki_iotrace",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_formatter_lua",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_utils_lua",
  "method": "code"
 },
 {
  "doc": "",
  "group": "arki_utils_lua",
  "method": "add_global_library"
 },
 {
  "doc": "",
  "group": "arki_utils_lua",
  "method": "arki_types"
 },
 {
  "doc": "",
  "group": "arki_utils_lua",
  "method": "arki_metadata"
 },
 {
  "doc": "",
  "group": "arki_utils_lua",
  "method": "arki_summary"
 },
 {
  "doc": "",
  "group": "arki_utils_lua",
  "method": "arki_matcher"
 },
 {
  "doc": "",
  "group": "arki_utils_lua",
  "method": "arki_code"
 },
 {
  "doc": "",
  "group": "arki_utils_lua",
  "method": "examples"
 },
 {
  "doc": "",
  "group": "arki_utils_vm2",
  "method": "find_stations"
 },
 {
  "doc": "",
  "group": "arki_utils_vm2",
  "method": "find_variables"
 },
 {
  "doc": "",
  "group": "arki_utils_vm2",
  "method": "get_station"
 },
 {
  "doc": "",
  "group": "arki_utils_vm2",
  "method": "get_variable"
 },
 {
  "doc": "",
  "group": "arki_utils_compress",
  "method": "incompressible"
 },
 {
  "doc": "",
  "group": "arki_utils_compress",
  "method": "roundtrip"
 },
 {
  "doc": "",
  "group": "arki_utils_compress",
  "method": "roundtrip_large"
 },
 {
  "doc": "",
  "group": "arki_utils_compress",
  "method": "indexwriter"
 },
 {
  "doc": "",
  "group": "arki_utils_compress",
  "method": "seekindex"
 },
 {
  "doc": "",
  "group": "arki_utils_compress",
  "method": "seekindex_lookup"
 },
 {
  "doc": "",
  "group": "arki_utils_compress",
  "method": "gzipwriter"
 },
 {
  "doc": "",
  "group": "arki_utils_compress",
  "method": "gzipindexingwriter"
 },
 {
  "doc": "",
  "group": "arki_utils_compress",
  "method": "seekindexreader"
 },
 {
  "doc": "",
  "group": "arki_utils_compress",
  "method": "seekindexreader_noindex"
 },
 {
  "doc": "",
  "group": "arki_utils_sqlite",
  "method": "oneshot"
 },
 {
  "doc": "",
  "group": "arki_utils_sqlite",
  "method": "precompile"
 },
 {
  "doc": "",
  "group": "arki_utils_sqlite",
  "method": "rollback"
 },
 {
  "doc": "",
  "group": "arki_utils_sqlite",
  "method": "64bit_size_t"
 },
 {
  "doc": "",
  "group": "arki_utils_sqlite",
  "method": "64bit_off_t"
 },
 {
  "doc": "",
  "group": "arki_sort",
  "method": "simple"
 },
 {
  "doc": "",
  "group": "arki_sort",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_formatter",
  "method": "yaml"
 },
 {
  "doc": "",
  "group": "arki_validator",
  "method": "fail_always"
 },
 {
  "doc": "",
  "group": "arki_validator",
  "method": "daily_import"
 },
 {
  "doc": "",
  "group": "arki_bbox",
  "method": "1"
 },
 {
  "doc": "",
  "group": "arki_bbox",
  "method": "2"
 },
 {
  "doc": "",
  "group": "arki_bbox",
  "method": "3"
 },
 {
  "doc": "",
  "group": "arki_bbox",
  "method": "4"
 },
 {
  "doc": "",
  "group": "arki_bbox",
  "method": "5"
 },
 {
  "doc": "",
  "group": "arki_bbox",
  "method": "6"
 },
 {
  "doc": "",
  "group": "arki_bbox",
  "method": "7"
 },
 {
  "doc": "",
  "group": "arki_metadata",
  "method": "sources"
 },
 {
  "doc": "",
  "group": "arki_metadata",
  "method": "binary"
 },
 {
  "doc": "",
  "group": "arki_metadata",
  "method": "yaml"
 },
 {
  "doc": "",
  "group": "arki_metadata",
  "method": "json"
 },
 {
  "doc": "",
  "group": "arki_metadata",
  "method": "binary_inline"
 },
 {
  "doc": "",
  "group": "arki_metadata",
  "method": "binary_fd"
 },
 {
  "doc": "",
  "group": "arki_metadata",
  "method": "decode_issue_24"
 },
 {
  "doc": "",
  "group": "arki_metadata",
  "method": "lua"
 },
 {
  "doc": "",
  "group": "arki_metadata",
  "method": "stream_grib"
 },
 {
  "doc": "",
  "group": "arki_metadata",
  "method": "stream_bufr"
 },
 {
  "doc": "",
  "group": "arki_metadata",
  "method": "stream_vm2"
 },
 {
  "doc": "",
  "group": "arki_metadata",
  "method": "stream_odim"
 },
 {
  "doc": "",
  "group": "arki_metadata",
  "method": "issue107_binary"
 },
 {
  "doc": "",
  "group": "arki_metadata",
  "method": "issue107_yaml"
 },
 {
  "doc": "",
  "group": "arki_metadata",
  "method": "wrongsize"
 },
 {
  "doc": "",
  "group": "arki_metadata_data",
  "method": "todo"
 },
 {
  "doc": "",
  "group": "arki_metadata_collection",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_metadata_clusterer",
  "method": "by_count"
 },
 {
  "doc": "",
  "group": "arki_metadata_clusterer",
  "method": "by_size"
 },
 {
  "doc": "",
  "group": "arki_metadata_clusterer",
  "method": "by_interval"
 },
 {
  "doc": "",
  "group": "arki_metadata_clusterer",
  "method": "by_timerange"
 },
 {
  "doc": "",
  "group": "arki_metadata_stream",
  "method": "stream"
 },
 {
  "doc": "",
  "group": "arki_metadata_stream",
  "method": "split"
 },
 {
  "doc": "",
  "group": "arki_metadata_libarchive",
  "method": "tar"
 },
 {
  "doc": "",
  "group": "arki_metadata_libarchive",
  "method": "targz"
 },
 {
  "doc": "",
  "group": "arki_metadata_libarchive",
  "method": "tarxz"
 },
 {
  "doc": "",
  "group": "arki_metadata_libarchive",
  "method": "zip"
 },
 {
  "doc": "",
  "group": "arki_metadata_test_generator",
  "method": "grib1"
 },
 {
  "doc": "",
  "group": "arki_metadata_test_generator",
  "method": "grib2"
 },
 {
  "doc": "",
  "group": "arki_metadata_test_generator",
  "method": "bufr"
 },
 {
  "doc": "",
  "group": "arki_metadata_test_generator",
  "method": "odimh5"
 },
 {
  "doc": "",
  "group": "arki_metadata_test_generator",
  "method": "grib1_extratypes"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "stats"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "compare"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "match"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "match_run"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "filter"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "binary"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "yaml"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "json"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "merge"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "binary_empty"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "regression0"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "lua"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "summarise_grib"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "add_with_stats"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "resolvematcher"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "binary_old"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "regression1"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "binary_old1"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "filter_empty_matcher"
 },
 {
  "doc": "",
  "group": "arki_summary",
  "method": "zero_timestamp"
 },
 {
  "doc": "",
  "group": "arki_summary_intern",
  "method": "basic"
 },
 {
  "doc": "",
  "group": "arki_summary_table",
  "method": "basic"
 },
 {
  "doc": "",
  "group": "arki_summary_table",
  "method": "merge"
 },
 {
  "doc": "",
  "group": "arki_summary_table",
  "method": "smalltable"
 },
 {
  "doc": "",
  "group": "arki_summary_table",
  "method": "bigtable"
 },
 {
  "doc": "",
  "group": "arki_summary_table",
  "method": "row"
 },
 {
  "doc": "",
  "group": "arki_summary_stats",
  "method": "basic"
 },
 {
  "doc": "",
  "group": "arki_summary_short",
  "method": "json"
 },
 {
  "doc": "",
  "group": "arki_summary_short",
  "method": "yaml"
 },
 {
  "doc": "",
  "group": "arki_matcher",
  "method": "tostring"
 },
 {
  "doc": "",
  "group": "arki_matcher",
  "method": "or"
 },
 {
  "doc": "",
  "group": "arki_matcher",
  "method": "aliases"
 },
 {
  "doc": "",
  "group": "arki_matcher",
  "method": "aliases_multilevel"
 },
 {
  "doc": "",
  "group": "arki_matcher",
  "method": "aliases_recursive_1"
 },
 {
  "doc": "",
  "group": "arki_matcher",
  "method": "aliases_recursive_2"
 },
 {
  "doc": "",
  "group": "arki_matcher",
  "method": "aliases_recursive_3"
 },
 {
  "doc": "",
  "group": "arki_matcher",
  "method": "aliases_multilevel_load"
 },
 {
  "doc": "",
  "group": "arki_matcher",
  "method": "aliases_doctest"
 },
 {
  "doc": "",
  "group": "arki_matcher",
  "method": "aliases_regression"
 },
 {
  "doc": "",
  "group": "arki_matcher_utils",
  "method": "optionalcommalist"
 },
 {
  "doc": "",
  "group": "arki_matcher_utils",
  "method": "commajoiner"
 },
 {
  "doc": "",
  "group": "arki_matcher_origin",
  "method": "grib1"
 },
 {
  "doc": "",
  "group": "arki_matcher_origin",
  "method": "bufr"
 },
 {
  "doc": "",
  "group": "arki_matcher_origin",
  "method": "odimh5"
 },
 {
  "doc": "",
  "group": "arki_matcher_product",
  "method": "grib"
 },
 {
  "doc": "",
  "group": "arki_matcher_product",
  "method": "bufr"
 },
 {
  "doc": "",
  "group": "arki_matcher_product",
  "method": "vm2"
 },
 {
  "doc": "",
  "group": "arki_matcher_level",
  "method": "grib1"
 },
 {
  "doc": "",
  "group": "arki_matcher_level",
  "method": "grib2s"
 },
 {
  "doc": "",
  "group": "arki_matcher_level",
  "method": "grib2d"
 },
 {
  "doc": "",
  "group": "arki_matcher_level",
  "method": "odimh5"
 },
 {
  "doc": "",
  "group": "arki_matcher_timerange",
  "method": "grib1"
 },
 {
  "doc": "",
  "group": "arki_matcher_timerange",
  "method": "grib2"
 },
 {
  "doc": "",
  "group": "arki_matcher_timerange",
  "method": "timedef"
 },
 {
  "doc": "",
  "group": "arki_matcher_timerange",
  "method": "bufr"
 },
 {
  "doc": "",
  "group": "arki_matcher_timerange",
  "method": "regression"
 },
 {
  "doc": "",
  "group": "arki_matcher_timerange",
  "method": "timedef_parse"
 },
 {
  "doc": "",
  "group": "arki_matcher_timerange",
  "method": "timedef_grib1"
 },
 {
  "doc": "",
  "group": "arki_matcher_timerange",
  "method": "timedef_grib2"
 },
 {
  "doc": "",
  "group": "arki_matcher_timerange",
  "method": "timedef_timedef"
 },
 {
  "doc": "",
  "group": "arki_matcher_timerange",
  "method": "timedef_bufr"
 },
 {
  "doc": "",
  "group": "arki_matcher_timerange",
  "method": "timedef_wellknown"
 },
 {
  "doc": "",
  "group": "arki_matcher_timerange",
  "method": "serialize"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime",
  "method": "match_position"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime",
  "method": "match_period"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime",
  "method": "regression1"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime",
  "method": "times"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime",
  "method": "time_repetition"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime",
  "method": "times1"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime",
  "method": "times2"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime_parser",
  "method": "parse"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime_parser",
  "method": "relative"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime_parser",
  "method": "mix"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime_parser",
  "method": "serialize_relative"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime_parser",
  "method": "offset"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime_parser",
  "method": "now"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime_parser",
  "method": "combine_itervals"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime_parser",
  "method": "ago"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime_parser",
  "method": "from_until"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime_parser",
  "method": "midday_midnight_noon"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime_parser",
  "method": "every"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime_parser",
  "method": "a_an"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime_parser",
  "method": "intervals_in_day"
 },
 {
  "doc": "",
  "group": "arki_matcher_reftime_parser",
  "method": "easter"
 },
 {
  "doc": "",
  "group": "arki_matcher_area",
  "method": "grib"
 },
 {
  "doc": "",
  "group": "arki_matcher_area",
  "method": "bbox_equals"
 },
 {
  "doc": "",
  "group": "arki_matcher_area",
  "method": "bbox_covers"
 },
 {
  "doc": "",
  "group": "arki_matcher_area",
  "method": "bbox_intersects"
 },
 {
  "doc": "",
  "group": "arki_matcher_area",
  "method": "bbox_coveredby"
 },
 {
  "doc": "",
  "group": "arki_matcher_area",
  "method": "odimh5"
 },
 {
  "doc": "",
  "group": "arki_matcher_area",
  "method": "odimh5_octagon"
 },
 {
  "doc": "",
  "group": "arki_matcher_area",
  "method": "bbox_odimh5"
 },
 {
  "doc": "",
  "group": "arki_matcher_area",
  "method": "vm2"
 },
 {
  "doc": "",
  "group": "arki_matcher_proddef",
  "method": "grib"
 },
 {
  "doc": "",
  "group": "arki_matcher_run",
  "method": "minute"
 },
 {
  "doc": "",
  "group": "arki_matcher_source",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_matcher_task",
  "method": "odim"
 },
 {
  "doc": "",
  "group": "arki_matcher_quantity",
  "method": "odim"
 },
 {
  "doc": "",
  "group": "arki_scan",
  "method": "format_from_filename"
 },
 {
  "doc": "",
  "group": "arki_scan",
  "method": "scan_file_grib"
 },
 {
  "doc": "",
  "group": "arki_scan",
  "method": "scan_singleton_grib"
 },
 {
  "doc": "",
  "group": "arki_scan",
  "method": "scan_pipe_grib"
 },
 {
  "doc": "",
  "group": "arki_scan",
  "method": "scan_file_bufr"
 },
 {
  "doc": "",
  "group": "arki_scan",
  "method": "scan_singleton_bufr"
 },
 {
  "doc": "",
  "group": "arki_scan",
  "method": "scan_pipe_bufr"
 },
 {
  "doc": "",
  "group": "arki_scan",
  "method": "scan_file_vm2"
 },
 {
  "doc": "",
  "group": "arki_scan",
  "method": "scan_singleton_vm2"
 },
 {
  "doc": "",
  "group": "arki_scan",
  "method": "scan_pipe_vm2"
 },
 {
  "doc": "",
  "group": "arki_scan",
  "method": "scan_file_odimh5"
 },
 {
  "doc": "",
  "group": "arki_scan",
  "method": "scan_singleton_odimh5"
 },
 {
  "doc": "",
  "group": "arki_scan",
  "method": "scan_pipe_odimh5"
 },
 {
  "doc": "",
  "group": "arki_scan",
  "method": "usn"
 },
 {
  "doc": "",
  "group": "arki_scan_validator",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_scan_dir",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment",
  "method": "auto_instantiate_existing"
 },
 {
  "doc": "",
  "group": "arki_segment_common",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_segment_missing",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_grib",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_grib",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_grib",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_grib",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_grib",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_grib",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_grib",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_grib",
  "method": "append"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_grib",
  "method": "large"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_bufr",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_bufr",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_bufr",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_bufr",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_bufr",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_bufr",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_bufr",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_bufr",
  "method": "append"
 },
 {
  "doc": "",
  "group": "arki_segment_concat_bufr",
  "method": "large"
 },
 {
  "doc": "",
  "group": "arki_segment_lines_vm2",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_lines_vm2",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_lines_vm2",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_lines_vm2",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_lines_vm2",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_lines_vm2",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_lines_vm2",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_lines_vm2",
  "method": "append"
 },
 {
  "doc": "",
  "group": "arki_segment_lines_vm2",
  "method": "large"
 },
 {
  "doc": "",
  "group": "arki_segment_seqfile",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_grib",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_grib",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_grib",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_grib",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_grib",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_grib",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_grib",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_grib",
  "method": "append"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_bufr",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_bufr",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_bufr",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_bufr",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_bufr",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_bufr",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_bufr",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_bufr",
  "method": "append"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_odim",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_odim",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_odim",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_odim",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_odim",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_odim",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_odim",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_odim",
  "method": "append"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_vm2",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_vm2",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_vm2",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_vm2",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_vm2",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_vm2",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_vm2",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_dir_vm2",
  "method": "append"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_grib",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_grib",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_grib",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_grib",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_grib",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_grib",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_grib",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_bufr",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_bufr",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_bufr",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_bufr",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_bufr",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_bufr",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_bufr",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_odim",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_odim",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_odim",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_odim",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_odim",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_odim",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_odim",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_vm2",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_vm2",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_vm2",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_vm2",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_vm2",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_vm2",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_tar_vm2",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_grib",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_grib",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_grib",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_grib",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_grib",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_grib",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_grib",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_bufr",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_bufr",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_bufr",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_bufr",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_bufr",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_bufr",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_bufr",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_odim",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_odim",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_odim",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_odim",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_odim",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_odim",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_odim",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_vm2",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_vm2",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_vm2",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_vm2",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_vm2",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_vm2",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_zip_vm2",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib_nogroup",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib_nogroup",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib_nogroup",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib_nogroup",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib_nogroup",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib_nogroup",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib_nogroup",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib_nogroup",
  "method": "noidx"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib_nogroup",
  "method": "idx"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib_nogroup",
  "method": "onegroup"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr_nogroup",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr_nogroup",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr_nogroup",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr_nogroup",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr_nogroup",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr_nogroup",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr_nogroup",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr_nogroup",
  "method": "noidx"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr_nogroup",
  "method": "idx"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr_nogroup",
  "method": "onegroup"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2_nogroup",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2_nogroup",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2_nogroup",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2_nogroup",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2_nogroup",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2_nogroup",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2_nogroup",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2_nogroup",
  "method": "noidx"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2_nogroup",
  "method": "idx"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2_nogroup",
  "method": "onegroup"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib",
  "method": "noidx"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib",
  "method": "idx"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_grib",
  "method": "onegroup"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr",
  "method": "noidx"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr",
  "method": "idx"
 },
 {
  "doc": "",
  "group": "arki_segment_gz_bufr",
  "method": "onegroup"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2",
  "method": "repack"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2",
  "method": "is_empty"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2",
  "method": "noidx"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2",
  "method": "idx"
 },
 {
  "doc": "",
  "group": "arki_segment_gzlines_vm2",
  "method": "onegroup"
 },
 {
  "doc": "",
  "group": "arki_runtime_io",
  "method": "tempfile"
 },
 {
  "doc": "",
  "group": "arki_runtime_inputs",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_runtime_config",
  "method": "restrict"
 },
 {
  "doc": "",
  "group": "arki_scan_grib",
  "method": "compact"
 },
 {
  "doc": "",
  "group": "arki_scan_grib",
  "method": "padded"
 },
 {
  "doc": "",
  "group": "arki_scan_grib",
  "method": "lua_results"
 },
 {
  "doc": "",
  "group": "arki_scan_grib",
  "method": "validation"
 },
 {
  "doc": "",
  "group": "arki_scan_grib",
  "method": "layers"
 },
 {
  "doc": "",
  "group": "arki_scan_grib",
  "method": "proselvo"
 },
 {
  "doc": "",
  "group": "arki_scan_grib",
  "method": "cleps"
 },
 {
  "doc": "",
  "group": "arki_scan_grib",
  "method": "utm_areas"
 },
 {
  "doc": "",
  "group": "arki_scan_grib",
  "method": "ninfa"
 },
 {
  "doc": "",
  "group": "arki_scan_grib",
  "method": "cosmo_nudging"
 },
 {
  "doc": "",
  "group": "arki_scan_grib",
  "method": "issue120"
 },
 {
  "doc": "",
  "group": "arki_scan_bufr",
  "method": "contiguous"
 },
 {
  "doc": "",
  "group": "arki_scan_bufr",
  "method": "padded"
 },
 {
  "doc": "",
  "group": "arki_scan_bufr",
  "method": "validate"
 },
 {
  "doc": "",
  "group": "arki_scan_bufr",
  "method": "partial"
 },
 {
  "doc": "",
  "group": "arki_scan_bufr",
  "method": "pollution"
 },
 {
  "doc": "",
  "group": "arki_scan_bufr",
  "method": "zerodate"
 },
 {
  "doc": "",
  "group": "arki_scan_bufr",
  "method": "ship"
 },
 {
  "doc": "",
  "group": "arki_scan_bufr",
  "method": "amdar"
 },
 {
  "doc": "",
  "group": "arki_scan_bufr",
  "method": "airep"
 },
 {
  "doc": "",
  "group": "arki_scan_bufr",
  "method": "acars"
 },
 {
  "doc": "",
  "group": "arki_scan_bufr",
  "method": "gts"
 },
 {
  "doc": "",
  "group": "arki_scan_bufr",
  "method": "date_mismatch"
 },
 {
  "doc": "",
  "group": "arki_scan_bufr",
  "method": "out_of_range"
 },
 {
  "doc": "",
  "group": "arki_scan_bufr",
  "method": "temp_reftime"
 },
 {
  "doc": "",
  "group": "arki_scan_bufr",
  "method": "wrongdate"
 },
 {
  "doc": "",
  "group": "arki_utils_h5",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "pvol"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "comp_cappi"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "comp_etop"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "comp_lbm"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "comp_max"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "comp_pcappi"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "comp_ppi"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "comp_rr"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "comp_vil"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "image_cappi"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "image_etop"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "image_hvmi"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "image_max"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "image_pcappi"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "image_ppi"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "image_rr"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "image_vil"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "image_zlr_bb"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "xsec"
 },
 {
  "doc": "",
  "group": "arki_scan_odimh5",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_scan_vm2",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_scan_vm2",
  "method": "scan_seconds"
 },
 {
  "doc": "",
  "group": "arki_scan_vm2",
  "method": "validate"
 },
 {
  "doc": "",
  "group": "arki_scan_vm2",
  "method": "reconstruct"
 },
 {
  "doc": "",
  "group": "arki_scan_vm2",
  "method": "corrupted"
 },
 {
  "doc": "",
  "group": "arki_targetfile",
  "method": "echo"
 },
 {
  "doc": "",
  "group": "arki_targetfile",
  "method": "mars"
 },
 {
  "doc": "",
  "group": "arki_metadata_xargs",
  "method": "check_stdin"
 },
 {
  "doc": "",
  "group": "arki_metadata_xargs",
  "method": "check_env"
 },
 {
  "doc": "",
  "group": "arki_metadata_xargs",
  "method": "interval"
 },
 {
  "doc": "",
  "group": "arki_metadata_xargs",
  "method": "issue124"
 },
 {
  "doc": "",
  "group": "arki_metadata_xargs",
  "method": "check_tmpfile_exist"
 },
 {
  "doc": "",
  "group": "arki_dataset_lock",
  "method": "reader_reader"
 },
 {
  "doc": "",
  "group": "arki_dataset_lock",
  "method": "reader_append"
 },
 {
  "doc": "",
  "group": "arki_dataset_lock",
  "method": "reader_checkro"
 },
 {
  "doc": "",
  "group": "arki_dataset_lock",
  "method": "reader_checkrw"
 },
 {
  "doc": "",
  "group": "arki_dataset_lock",
  "method": "append_append"
 },
 {
  "doc": "",
  "group": "arki_dataset_lock",
  "method": "append_checkro"
 },
 {
  "doc": "",
  "group": "arki_dataset_lock",
  "method": "append_checkrw"
 },
 {
  "doc": "",
  "group": "arki_dataset_lock",
  "method": "checkro_checkro"
 },
 {
  "doc": "",
  "group": "arki_dataset_lock",
  "method": "checkro_checkrw"
 },
 {
  "doc": "",
  "group": "arki_dataset_reporter",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_dataset_time",
  "method": "default"
 },
 {
  "doc": "",
  "group": "arki_dataset_time",
  "method": "override"
 },
 {
  "doc": "",
  "group": "arki_dataset_segment",
  "method": "scan_dir_empty"
 },
 {
  "doc": "",
  "group": "arki_dataset_segment",
  "method": "scan_dir_dir1"
 },
 {
  "doc": "",
  "group": "arki_dataset_segment",
  "method": "scan_dir_dir2"
 },
 {
  "doc": "",
  "group": "arki_dataset_segment",
  "method": "scan_dir_dir2"
 },
 {
  "doc": "",
  "group": "arki_dataset_segment_managers",
  "method": "auto_instantiate_new"
 },
 {
  "doc": "",
  "group": "arki_dataset_segment_managers",
  "method": "forcedir_instantiate_new"
 },
 {
  "doc": "",
  "group": "arki_dataset_memory",
  "method": "query"
 },
 {
  "doc": "",
  "group": "arki_dataset_memory",
  "method": "query_summary"
 },
 {
  "doc": "",
  "group": "arki_dataset_memory",
  "method": "query_summary_reftime"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_tests_manifest_plain",
  "method": "has_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_tests_manifest_plain",
  "method": "segment_timespan"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_tests_manifest_plain",
  "method": "list_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_tests_manifest_plain",
  "method": "list_segments_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_tests_manifest_sqlite",
  "method": "has_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_tests_manifest_sqlite",
  "method": "segment_timespan"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_tests_manifest_sqlite",
  "method": "list_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_tests_manifest_sqlite",
  "method": "list_segments_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_tests_contents",
  "method": "has_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_tests_contents",
  "method": "segment_timespan"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_tests_contents",
  "method": "list_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_tests_contents",
  "method": "list_segments_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_base",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_attr",
  "method": "basic"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_attr",
  "method": "cold_cache"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_attr",
  "method": "obtainids"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_manifest",
  "method": "exists"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_manifest",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_manifest",
  "method": "create"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_manifest",
  "method": "add_remove"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_manifest",
  "method": "modify_while_scanning"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_aggregate",
  "method": "basic"
 },
 {
  "doc": "",
  "group": "arki_dataset_index_summarycache",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_dataset_step",
  "method": "single"
 },
 {
  "doc": "",
  "group": "arki_dataset_step",
  "method": "yearly"
 },
 {
  "doc": "",
  "group": "arki_dataset_step",
  "method": "monthly"
 },
 {
  "doc": "",
  "group": "arki_dataset_step",
  "method": "biweekly"
 },
 {
  "doc": "",
  "group": "arki_dataset_step",
  "method": "weekly"
 },
 {
  "doc": "",
  "group": "arki_dataset_step",
  "method": "daily"
 },
 {
  "doc": "",
  "group": "arki_dataset_local",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_ondisk2",
  "method": "gz"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_ondisk2",
  "method": "gzidx"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_ondisk2",
  "method": "tarred"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_ondisk2",
  "method": "zipped"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_ondisk2",
  "method": "query_archived"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_ondisk2",
  "method": "empty_dirs"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_ondisk2",
  "method": "query_lots"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_ondisk2",
  "method": "archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_ondisk2",
  "method": "delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_ondisk2",
  "method": "unarchive_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_ondisk2",
  "method": "unarchive_segment_lastonly"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_plain",
  "method": "gz"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_plain",
  "method": "gzidx"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_plain",
  "method": "tarred"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_plain",
  "method": "zipped"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_plain",
  "method": "query_archived"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_plain",
  "method": "empty_dirs"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_plain",
  "method": "query_lots"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_plain",
  "method": "archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_plain",
  "method": "delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_plain",
  "method": "unarchive_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_plain",
  "method": "unarchive_segment_lastonly"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_sqlite",
  "method": "gz"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_sqlite",
  "method": "gzidx"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_sqlite",
  "method": "tarred"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_sqlite",
  "method": "zipped"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_sqlite",
  "method": "query_archived"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_sqlite",
  "method": "empty_dirs"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_sqlite",
  "method": "query_lots"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_sqlite",
  "method": "archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_sqlite",
  "method": "delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_sqlite",
  "method": "unarchive_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_simple_sqlite",
  "method": "unarchive_segment_lastonly"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_iseg",
  "method": "gz"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_iseg",
  "method": "gzidx"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_iseg",
  "method": "tarred"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_iseg",
  "method": "zipped"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_iseg",
  "method": "query_archived"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_iseg",
  "method": "empty_dirs"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_iseg",
  "method": "query_lots"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_iseg",
  "method": "archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_iseg",
  "method": "delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_iseg",
  "method": "unarchive_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_iseg",
  "method": "unarchive_segment_lastonly"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_issue103_ondisk2",
  "method": "issue103"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_issue103_ondisk2_dir",
  "method": "issue103"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_issue103_simple_plain",
  "method": "issue103"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_issue103_simple_plain_dir",
  "method": "issue103"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_issue103_simple_sqlite",
  "method": "issue103"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_issue103_simple_sqlite_dir",
  "method": "issue103"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_issue103_iseg",
  "method": "issue103"
 },
 {
  "doc": "",
  "group": "arki_dataset_segmented_issue103_iseg_dir",
  "method": "issue103"
 },
 {
  "doc": "",
  "group": "arki_dataset_indexed",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_dataset_file",
  "method": "grib"
 },
 {
  "doc": "",
  "group": "arki_dataset_file",
  "method": "grib_as_bufr"
 },
 {
  "doc": "",
  "group": "arki_dataset_file",
  "method": "grib_strangename"
 },
 {
  "doc": "",
  "group": "arki_dataset_file",
  "method": "metadata"
 },
 {
  "doc": "",
  "group": "arki_dataset_file",
  "method": "yaml"
 },
 {
  "doc": "",
  "group": "arki_dataset_archive",
  "method": "acquire_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_archive",
  "method": "maintenance_nonindexed"
 },
 {
  "doc": "",
  "group": "arki_dataset_archive",
  "method": "reader_empty_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_archive",
  "method": "enumerate_no_manifest"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_reader_plain",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_reader_sqlite",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_writer",
  "method": "acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_writer",
  "method": "append"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_writer",
  "method": "testacquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_checker",
  "method": "scan_missing_summary"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_checker",
  "method": "scan_compressed"
 },
 {
  "doc": "- the segment must be a file",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_isfile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "fix_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "repack_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "repack_timestamps"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_new"
 },
 {
  "doc": "- the segment must not be newer than the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_unaligned"
 },
 {
  "doc": "- `.metadata` file must not be empty [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_empty_metadata"
 },
 {
  "doc": "- `.metadata` file must not be older than the data [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_metadata_timestamp"
 },
 {
  "doc": "- `.summary` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_summary_timestamp"
 },
 {
  "doc": "- `MANIFEST` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_manifest_timestamp"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and a check will rebuild it. Until it gets rebuilt, segments\n  not present in the index would not be considered when querying the\n  dataset",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- metadata in the `.metadata` file must contain reference time elements [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "check_metadata_must_contain_reftimes"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_plain",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a file",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_isfile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "fix_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "repack_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "repack_timestamps"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_new"
 },
 {
  "doc": "- the segment must not be newer than the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_unaligned"
 },
 {
  "doc": "- `.metadata` file must not be empty [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_empty_metadata"
 },
 {
  "doc": "- `.metadata` file must not be older than the data [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_metadata_timestamp"
 },
 {
  "doc": "- `.summary` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_summary_timestamp"
 },
 {
  "doc": "- `MANIFEST` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_manifest_timestamp"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and a check will rebuild it. Until it gets rebuilt, segments\n  not present in the index would not be considered when querying the\n  dataset",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- metadata in the `.metadata` file must contain reference time elements [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "check_metadata_must_contain_reftimes"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_sqlite",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a directory [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_isdir"
 },
 {
  "doc": "- the size of each data file must match the data size exactly [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_datasize"
 },
 {
  "doc": "- the modification time of a directory segment can vary unpredictably,\n  so it is ignored. The modification time of the sequence file is used\n  instead.",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_ignore_dir_timestamp"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_new"
 },
 {
  "doc": "- the segment must not be newer than the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_unaligned"
 },
 {
  "doc": "- `.metadata` file must not be empty [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_empty_metadata"
 },
 {
  "doc": "- `.metadata` file must not be older than the data [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_metadata_timestamp"
 },
 {
  "doc": "- `.summary` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_summary_timestamp"
 },
 {
  "doc": "- `MANIFEST` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_manifest_timestamp"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and a check will rebuild it. Until it gets rebuilt, segments\n  not present in the index would not be considered when querying the\n  dataset",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- metadata in the `.metadata` file must contain reference time elements [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "check_metadata_must_contain_reftimes"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_plain_dirs",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a directory [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_isdir"
 },
 {
  "doc": "- the size of each data file must match the data size exactly [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_datasize"
 },
 {
  "doc": "- the modification time of a directory segment can vary unpredictably,\n  so it is ignored. The modification time of the sequence file is used\n  instead.",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_ignore_dir_timestamp"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_new"
 },
 {
  "doc": "- the segment must not be newer than the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_unaligned"
 },
 {
  "doc": "- `.metadata` file must not be empty [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_empty_metadata"
 },
 {
  "doc": "- `.metadata` file must not be older than the data [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_metadata_timestamp"
 },
 {
  "doc": "- `.summary` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_summary_timestamp"
 },
 {
  "doc": "- `MANIFEST` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_manifest_timestamp"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and a check will rebuild it. Until it gets rebuilt, segments\n  not present in the index would not be considered when querying the\n  dataset",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- metadata in the `.metadata` file must contain reference time elements [corrupted]",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "check_metadata_must_contain_reftimes"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_simple_maintenance_grib_sqlite_dirs",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a file",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_isfile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "fix_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "repack_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "repack_timestamps"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_new"
 },
 {
  "doc": "- the segment must not be newer than the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_unaligned"
 },
 {
  "doc": "- `.metadata` file must not be empty [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_empty_metadata"
 },
 {
  "doc": "- `.metadata` file must not be older than the data [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_metadata_timestamp"
 },
 {
  "doc": "- `.summary` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_summary_timestamp"
 },
 {
  "doc": "- `MANIFEST` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_manifest_timestamp"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and a check will rebuild it. Until it gets rebuilt, segments\n  not present in the index would not be considered when querying the\n  dataset",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- metadata in the `.metadata` file must contain reference time elements [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "check_metadata_must_contain_reftimes"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_plain",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a file",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_isfile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "fix_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "repack_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "repack_timestamps"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_new"
 },
 {
  "doc": "- the segment must not be newer than the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_unaligned"
 },
 {
  "doc": "- `.metadata` file must not be empty [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_empty_metadata"
 },
 {
  "doc": "- `.metadata` file must not be older than the data [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_metadata_timestamp"
 },
 {
  "doc": "- `.summary` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_summary_timestamp"
 },
 {
  "doc": "- `MANIFEST` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_manifest_timestamp"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and a check will rebuild it. Until it gets rebuilt, segments\n  not present in the index would not be considered when querying the\n  dataset",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- metadata in the `.metadata` file must contain reference time elements [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "check_metadata_must_contain_reftimes"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a directory [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_isdir"
 },
 {
  "doc": "- the size of each data file must match the data size exactly [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_datasize"
 },
 {
  "doc": "- the modification time of a directory segment can vary unpredictably,\n  so it is ignored. The modification time of the sequence file is used\n  instead.",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_ignore_dir_timestamp"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_new"
 },
 {
  "doc": "- the segment must not be newer than the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_unaligned"
 },
 {
  "doc": "- `.metadata` file must not be empty [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_empty_metadata"
 },
 {
  "doc": "- `.metadata` file must not be older than the data [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_metadata_timestamp"
 },
 {
  "doc": "- `.summary` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_summary_timestamp"
 },
 {
  "doc": "- `MANIFEST` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_manifest_timestamp"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and a check will rebuild it. Until it gets rebuilt, segments\n  not present in the index would not be considered when querying the\n  dataset",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- metadata in the `.metadata` file must contain reference time elements [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "check_metadata_must_contain_reftimes"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_plain_dirs",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a directory [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_isdir"
 },
 {
  "doc": "- the size of each data file must match the data size exactly [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_datasize"
 },
 {
  "doc": "- the modification time of a directory segment can vary unpredictably,\n  so it is ignored. The modification time of the sequence file is used\n  instead.",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_ignore_dir_timestamp"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_new"
 },
 {
  "doc": "- the segment must not be newer than the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_unaligned"
 },
 {
  "doc": "- `.metadata` file must not be empty [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_empty_metadata"
 },
 {
  "doc": "- `.metadata` file must not be older than the data [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_metadata_timestamp"
 },
 {
  "doc": "- `.summary` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_summary_timestamp"
 },
 {
  "doc": "- `MANIFEST` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_manifest_timestamp"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and a check will rebuild it. Until it gets rebuilt, segments\n  not present in the index would not be considered when querying the\n  dataset",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- metadata in the `.metadata` file must contain reference time elements [corrupted]",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "check_metadata_must_contain_reftimes"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_simple_maintenance_bufr_sqlite_dirs",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a file",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_isfile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "fix_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "repack_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "repack_timestamps"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_new"
 },
 {
  "doc": "- the segment must not be newer than the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_unaligned"
 },
 {
  "doc": "- `.metadata` file must not be empty [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_empty_metadata"
 },
 {
  "doc": "- `.metadata` file must not be older than the data [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_metadata_timestamp"
 },
 {
  "doc": "- `.summary` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_summary_timestamp"
 },
 {
  "doc": "- `MANIFEST` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_manifest_timestamp"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and a check will rebuild it. Until it gets rebuilt, segments\n  not present in the index would not be considered when querying the\n  dataset",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- metadata in the `.metadata` file must contain reference time elements [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "check_metadata_must_contain_reftimes"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_plain",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a file",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_isfile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "fix_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "repack_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "repack_timestamps"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_new"
 },
 {
  "doc": "- the segment must not be newer than the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_unaligned"
 },
 {
  "doc": "- `.metadata` file must not be empty [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_empty_metadata"
 },
 {
  "doc": "- `.metadata` file must not be older than the data [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_metadata_timestamp"
 },
 {
  "doc": "- `.summary` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_summary_timestamp"
 },
 {
  "doc": "- `MANIFEST` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_manifest_timestamp"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and a check will rebuild it. Until it gets rebuilt, segments\n  not present in the index would not be considered when querying the\n  dataset",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- metadata in the `.metadata` file must contain reference time elements [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "check_metadata_must_contain_reftimes"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a directory [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_isdir"
 },
 {
  "doc": "- the size of each data file must match the data size exactly [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_datasize"
 },
 {
  "doc": "- the modification time of a directory segment can vary unpredictably,\n  so it is ignored. The modification time of the sequence file is used\n  instead.",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_ignore_dir_timestamp"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_new"
 },
 {
  "doc": "- the segment must not be newer than the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_unaligned"
 },
 {
  "doc": "- `.metadata` file must not be empty [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_empty_metadata"
 },
 {
  "doc": "- `.metadata` file must not be older than the data [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_metadata_timestamp"
 },
 {
  "doc": "- `.summary` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_summary_timestamp"
 },
 {
  "doc": "- `MANIFEST` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_manifest_timestamp"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and a check will rebuild it. Until it gets rebuilt, segments\n  not present in the index would not be considered when querying the\n  dataset",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- metadata in the `.metadata` file must contain reference time elements [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "check_metadata_must_contain_reftimes"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_plain_dirs",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a directory [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_isdir"
 },
 {
  "doc": "- the size of each data file must match the data size exactly [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_datasize"
 },
 {
  "doc": "- the modification time of a directory segment can vary unpredictably,\n  so it is ignored. The modification time of the sequence file is used\n  instead.",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_ignore_dir_timestamp"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_new"
 },
 {
  "doc": "- the segment must not be newer than the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_unaligned"
 },
 {
  "doc": "- `.metadata` file must not be empty [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_empty_metadata"
 },
 {
  "doc": "- `.metadata` file must not be older than the data [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_metadata_timestamp"
 },
 {
  "doc": "- `.summary` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_summary_timestamp"
 },
 {
  "doc": "- `MANIFEST` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_manifest_timestamp"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and a check will rebuild it. Until it gets rebuilt, segments\n  not present in the index would not be considered when querying the\n  dataset",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- metadata in the `.metadata` file must contain reference time elements [corrupted]",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "check_metadata_must_contain_reftimes"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_simple_maintenance_vm2_sqlite_dirs",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a directory [unaligned]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_isdir"
 },
 {
  "doc": "- the size of each data file must match the data size exactly [corrupted]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_datasize"
 },
 {
  "doc": "- the modification time of a directory segment can vary unpredictably,\n  so it is ignored. The modification time of the sequence file is used\n  instead.",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_ignore_dir_timestamp"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_new"
 },
 {
  "doc": "- the segment must not be newer than the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_unaligned"
 },
 {
  "doc": "- `.metadata` file must not be empty [unaligned]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_empty_metadata"
 },
 {
  "doc": "- `.metadata` file must not be older than the data [unaligned]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_metadata_timestamp"
 },
 {
  "doc": "- `.summary` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_summary_timestamp"
 },
 {
  "doc": "- `MANIFEST` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_manifest_timestamp"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and a check will rebuild it. Until it gets rebuilt, segments\n  not present in the index would not be considered when querying the\n  dataset",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- metadata in the `.metadata` file must contain reference time elements [corrupted]",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "check_metadata_must_contain_reftimes"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_simple_maintenance_odimh5_plain",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a directory [unaligned]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_isdir"
 },
 {
  "doc": "- the size of each data file must match the data size exactly [corrupted]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_datasize"
 },
 {
  "doc": "- the modification time of a directory segment can vary unpredictably,\n  so it is ignored. The modification time of the sequence file is used\n  instead.",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_ignore_dir_timestamp"
 },
 {
  "doc": "",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_new"
 },
 {
  "doc": "- the segment must not be newer than the index [unaligned]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_unaligned"
 },
 {
  "doc": "- `.metadata` file must not be empty [unaligned]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_empty_metadata"
 },
 {
  "doc": "- `.metadata` file must not be older than the data [unaligned]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_metadata_timestamp"
 },
 {
  "doc": "- `.summary` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_summary_timestamp"
 },
 {
  "doc": "- `MANIFEST` file must not be older than the `.metadata` file [unaligned]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_manifest_timestamp"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and a check will rebuild it. Until it gets rebuilt, segments\n  not present in the index would not be considered when querying the\n  dataset",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- metadata in the `.metadata` file must contain reference time elements [corrupted]",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "check_metadata_must_contain_reftimes"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_simple_maintenance_odimh5_sqlite",
  "method": "repack_unaligned"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg",
  "method": "acquire_replace_usn"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_index",
  "method": "locks"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_reader",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_writer",
  "method": "acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_writer",
  "method": "testacquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_checker",
  "method": "empty"
 },
 {
  "doc": "- the segment must be a file",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "check_isfile"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "check_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "fix_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "repack_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "repack_timestamps"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- segments that contain some data that has been removed are\n  identified as to be repacked [dirty]",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "check_one_removed"
 },
 {
  "doc": "- segments that only contain data that has been removed are\n  identified as fully deleted [deleted]",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "check_all_removed"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "fix_one_removed"
 },
 {
  "doc": "- [deleted] segments are left untouched",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "fix_deleted"
 },
 {
  "doc": "- [deleted] segments are removed from disk",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "repack_deleted"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "repack_one_removed"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "check_new"
 },
 {
  "doc": "- segments found in the dataset without a `.index` file are marked for rescanning [unaligned]",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "check_unaligned"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_grib",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a directory [unaligned]",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "check_isdir"
 },
 {
  "doc": "- the size of each data file must match the data size exactly [corrupted]",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "check_datasize"
 },
 {
  "doc": "- the modification time of a directory segment can vary unpredictably,\n  so it is ignored. The modification time of the sequence file is used\n  instead.",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "check_ignore_dir_timestamp"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- segments that contain some data that has been removed are\n  identified as to be repacked [dirty]",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "check_one_removed"
 },
 {
  "doc": "- segments that only contain data that has been removed are\n  identified as fully deleted [deleted]",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "check_all_removed"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "fix_one_removed"
 },
 {
  "doc": "- [deleted] segments are left untouched",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "fix_deleted"
 },
 {
  "doc": "- [deleted] segments are removed from disk",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "repack_deleted"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "repack_one_removed"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "check_dataexists"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "check_new"
 },
 {
  "doc": "- segments found in the dataset without a `.index` file are marked for rescanning [unaligned]",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "check_unaligned"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_grib_dirs",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a file",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "check_isfile"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "check_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "fix_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "repack_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "repack_timestamps"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- segments that contain some data that has been removed are\n  identified as to be repacked [dirty]",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "check_one_removed"
 },
 {
  "doc": "- segments that only contain data that has been removed are\n  identified as fully deleted [deleted]",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "check_all_removed"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "fix_one_removed"
 },
 {
  "doc": "- [deleted] segments are left untouched",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "fix_deleted"
 },
 {
  "doc": "- [deleted] segments are removed from disk",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "repack_deleted"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "repack_one_removed"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "check_new"
 },
 {
  "doc": "- segments found in the dataset without a `.index` file are marked for rescanning [unaligned]",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "check_unaligned"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_bufr",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a directory [unaligned]",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "check_isdir"
 },
 {
  "doc": "- the size of each data file must match the data size exactly [corrupted]",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "check_datasize"
 },
 {
  "doc": "- the modification time of a directory segment can vary unpredictably,\n  so it is ignored. The modification time of the sequence file is used\n  instead.",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "check_ignore_dir_timestamp"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- segments that contain some data that has been removed are\n  identified as to be repacked [dirty]",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "check_one_removed"
 },
 {
  "doc": "- segments that only contain data that has been removed are\n  identified as fully deleted [deleted]",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "check_all_removed"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "fix_one_removed"
 },
 {
  "doc": "- [deleted] segments are left untouched",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "fix_deleted"
 },
 {
  "doc": "- [deleted] segments are removed from disk",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "repack_deleted"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "repack_one_removed"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "check_dataexists"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "check_new"
 },
 {
  "doc": "- segments found in the dataset without a `.index` file are marked for rescanning [unaligned]",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "check_unaligned"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_bufr_dirs",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a file",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "check_isfile"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "check_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "fix_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "repack_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "repack_timestamps"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- segments that contain some data that has been removed are\n  identified as to be repacked [dirty]",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "check_one_removed"
 },
 {
  "doc": "- segments that only contain data that has been removed are\n  identified as fully deleted [deleted]",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "check_all_removed"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "fix_one_removed"
 },
 {
  "doc": "- [deleted] segments are left untouched",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "fix_deleted"
 },
 {
  "doc": "- [deleted] segments are removed from disk",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "repack_deleted"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "repack_one_removed"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "check_new"
 },
 {
  "doc": "- segments found in the dataset without a `.index` file are marked for rescanning [unaligned]",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "check_unaligned"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_vm2",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a directory [unaligned]",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "check_isdir"
 },
 {
  "doc": "- the size of each data file must match the data size exactly [corrupted]",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "check_datasize"
 },
 {
  "doc": "- the modification time of a directory segment can vary unpredictably,\n  so it is ignored. The modification time of the sequence file is used\n  instead.",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "check_ignore_dir_timestamp"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- segments that contain some data that has been removed are\n  identified as to be repacked [dirty]",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "check_one_removed"
 },
 {
  "doc": "- segments that only contain data that has been removed are\n  identified as fully deleted [deleted]",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "check_all_removed"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "fix_one_removed"
 },
 {
  "doc": "- [deleted] segments are left untouched",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "fix_deleted"
 },
 {
  "doc": "- [deleted] segments are removed from disk",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "repack_deleted"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "repack_one_removed"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "check_dataexists"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "check_new"
 },
 {
  "doc": "- segments found in the dataset without a `.index` file are marked for rescanning [unaligned]",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "check_unaligned"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_vm2_dirs",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a directory [unaligned]",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "check_isdir"
 },
 {
  "doc": "- the size of each data file must match the data size exactly [corrupted]",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "check_datasize"
 },
 {
  "doc": "- the modification time of a directory segment can vary unpredictably,\n  so it is ignored. The modification time of the sequence file is used\n  instead.",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "check_ignore_dir_timestamp"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- segments that contain some data that has been removed are\n  identified as to be repacked [dirty]",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "check_one_removed"
 },
 {
  "doc": "- segments that only contain data that has been removed are\n  identified as fully deleted [deleted]",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "check_all_removed"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "fix_one_removed"
 },
 {
  "doc": "- [deleted] segments are left untouched",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "fix_deleted"
 },
 {
  "doc": "- [deleted] segments are removed from disk",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "repack_deleted"
 },
 {
  "doc": "",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "repack_one_removed"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "check_dataexists"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "repack_archive"
 },
 {
  "doc": "- find data files not known by the index [unaligned]",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "check_new"
 },
 {
  "doc": "- segments found in the dataset without a `.index` file are marked for rescanning [unaligned]",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "check_unaligned"
 },
 {
  "doc": "- [unaligned] segments are not touched",
  "group": "arki_dataset_iseg_maintenance_odimh5",
  "method": "repack_unaligned"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2",
  "method": "acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2",
  "method": "replace"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2",
  "method": "query_summary"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2",
  "method": "query_summary_reftime"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2",
  "method": "acquire_replace"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2",
  "method": "query_first_reftime_extreme"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2",
  "method": "acquire_compressed"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2",
  "method": "acquire_replace_usn"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_index",
  "method": "index"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_index",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_index",
  "method": "concurrent"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_index",
  "method": "query_file"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_index",
  "method": "reproduce_old_issue1"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_index",
  "method": "largefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_index",
  "method": "smallfiles"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_reader",
  "method": "summaries"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_writer",
  "method": "summary_invalidate"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_writer",
  "method": "regression_0"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_writer",
  "method": "issue57"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_writer",
  "method": "testacquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_checker",
  "method": "reindex_with_duplicates"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_checker",
  "method": "scan_reindex"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_checker",
  "method": "scan_reindex_compressed"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_checker",
  "method": "summary_checks"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_checker",
  "method": "data_in_right_segment_reindex"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_checker",
  "method": "data_in_right_segment_rescan"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_checker",
  "method": "pack_vm2"
 },
 {
  "doc": "- the segment must be a file",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_isfile"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "fix_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "repack_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "repack_timestamps"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- segments that contain some data that has been removed are\n  identified as to be repacked [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_one_removed"
 },
 {
  "doc": "- segments that only contain data that has been removed are\n  identified as fully deleted [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_all_removed"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "fix_one_removed"
 },
 {
  "doc": "- [deleted] segments are left untouched",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "fix_deleted"
 },
 {
  "doc": "- [deleted] segments are removed from disk",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "repack_deleted"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "repack_one_removed"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "repack_archive"
 },
 {
  "doc": "- data files not known by the index are considered data files whose\n  entire content has been removed [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_new"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and creates a `needs-check-do-not-pack` file in the root of\n  the dataset.",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- while `needs-check-do-not-pack` is present, files with gaps are\n  marked for rescanning instead of repacking. This prevents a scenario\n  in which, after the index has been deleted, and some data has been\n  imported that got appended to an existing segment, that segment would\n  be considered as needing repack instead of rescan. [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_missing_index_rescan_partial_files"
 },
 {
  "doc": "- if a `needs-check-do-not-pack` file is present, segments not known by\n  the index are marked for reindexing instead of deletion [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "check_unaligned"
 },
 {
  "doc": "- [unaligned] when `needs-check-do-not-pack` is present in the dataset\n  root directory, running a repack fails asking to run a check first,\n  to prevent deleting data that should be reindexed instead",
  "group": "arki_dataset_ondisk2_maintenance_grib",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a directory [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_isdir"
 },
 {
  "doc": "- the size of each data file must match the data size exactly [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_datasize"
 },
 {
  "doc": "- the modification time of a directory segment can vary unpredictably,\n  so it is ignored. The modification time of the sequence file is used\n  instead.",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_ignore_dir_timestamp"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- segments that contain some data that has been removed are\n  identified as to be repacked [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_one_removed"
 },
 {
  "doc": "- segments that only contain data that has been removed are\n  identified as fully deleted [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_all_removed"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "fix_one_removed"
 },
 {
  "doc": "- [deleted] segments are left untouched",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "fix_deleted"
 },
 {
  "doc": "- [deleted] segments are removed from disk",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "repack_deleted"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "repack_one_removed"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "repack_archive"
 },
 {
  "doc": "- data files not known by the index are considered data files whose\n  entire content has been removed [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_new"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and creates a `needs-check-do-not-pack` file in the root of\n  the dataset.",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- while `needs-check-do-not-pack` is present, files with gaps are\n  marked for rescanning instead of repacking. This prevents a scenario\n  in which, after the index has been deleted, and some data has been\n  imported that got appended to an existing segment, that segment would\n  be considered as needing repack instead of rescan. [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_missing_index_rescan_partial_files"
 },
 {
  "doc": "- if a `needs-check-do-not-pack` file is present, segments not known by\n  the index are marked for reindexing instead of deletion [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "check_unaligned"
 },
 {
  "doc": "- [unaligned] when `needs-check-do-not-pack` is present in the dataset\n  root directory, running a repack fails asking to run a check first,\n  to prevent deleting data that should be reindexed instead",
  "group": "arki_dataset_ondisk2_maintenance_grib_dirs",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a file",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_isfile"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "fix_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "repack_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "repack_timestamps"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- segments that contain some data that has been removed are\n  identified as to be repacked [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_one_removed"
 },
 {
  "doc": "- segments that only contain data that has been removed are\n  identified as fully deleted [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_all_removed"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "fix_one_removed"
 },
 {
  "doc": "- [deleted] segments are left untouched",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "fix_deleted"
 },
 {
  "doc": "- [deleted] segments are removed from disk",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "repack_deleted"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "repack_one_removed"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "repack_archive"
 },
 {
  "doc": "- data files not known by the index are considered data files whose\n  entire content has been removed [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_new"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and creates a `needs-check-do-not-pack` file in the root of\n  the dataset.",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- while `needs-check-do-not-pack` is present, files with gaps are\n  marked for rescanning instead of repacking. This prevents a scenario\n  in which, after the index has been deleted, and some data has been\n  imported that got appended to an existing segment, that segment would\n  be considered as needing repack instead of rescan. [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_missing_index_rescan_partial_files"
 },
 {
  "doc": "- if a `needs-check-do-not-pack` file is present, segments not known by\n  the index are marked for reindexing instead of deletion [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "check_unaligned"
 },
 {
  "doc": "- [unaligned] when `needs-check-do-not-pack` is present in the dataset\n  root directory, running a repack fails asking to run a check first,\n  to prevent deleting data that should be reindexed instead",
  "group": "arki_dataset_ondisk2_maintenance_bufr",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a directory [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_isdir"
 },
 {
  "doc": "- the size of each data file must match the data size exactly [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_datasize"
 },
 {
  "doc": "- the modification time of a directory segment can vary unpredictably,\n  so it is ignored. The modification time of the sequence file is used\n  instead.",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_ignore_dir_timestamp"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- segments that contain some data that has been removed are\n  identified as to be repacked [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_one_removed"
 },
 {
  "doc": "- segments that only contain data that has been removed are\n  identified as fully deleted [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_all_removed"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "fix_one_removed"
 },
 {
  "doc": "- [deleted] segments are left untouched",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "fix_deleted"
 },
 {
  "doc": "- [deleted] segments are removed from disk",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "repack_deleted"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "repack_one_removed"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "repack_archive"
 },
 {
  "doc": "- data files not known by the index are considered data files whose\n  entire content has been removed [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_new"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and creates a `needs-check-do-not-pack` file in the root of\n  the dataset.",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- while `needs-check-do-not-pack` is present, files with gaps are\n  marked for rescanning instead of repacking. This prevents a scenario\n  in which, after the index has been deleted, and some data has been\n  imported that got appended to an existing segment, that segment would\n  be considered as needing repack instead of rescan. [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_missing_index_rescan_partial_files"
 },
 {
  "doc": "- if a `needs-check-do-not-pack` file is present, segments not known by\n  the index are marked for reindexing instead of deletion [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "check_unaligned"
 },
 {
  "doc": "- [unaligned] when `needs-check-do-not-pack` is present in the dataset\n  root directory, running a repack fails asking to run a check first,\n  to prevent deleting data that should be reindexed instead",
  "group": "arki_dataset_ondisk2_maintenance_bufr_dirs",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a file",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_isfile"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "fix_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "repack_hugefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "repack_timestamps"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- segments that contain some data that has been removed are\n  identified as to be repacked [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_one_removed"
 },
 {
  "doc": "- segments that only contain data that has been removed are\n  identified as fully deleted [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_all_removed"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "fix_one_removed"
 },
 {
  "doc": "- [deleted] segments are left untouched",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "fix_deleted"
 },
 {
  "doc": "- [deleted] segments are removed from disk",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "repack_deleted"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "repack_one_removed"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "repack_archive"
 },
 {
  "doc": "- data files not known by the index are considered data files whose\n  entire content has been removed [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_new"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and creates a `needs-check-do-not-pack` file in the root of\n  the dataset.",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- while `needs-check-do-not-pack` is present, files with gaps are\n  marked for rescanning instead of repacking. This prevents a scenario\n  in which, after the index has been deleted, and some data has been\n  imported that got appended to an existing segment, that segment would\n  be considered as needing repack instead of rescan. [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_missing_index_rescan_partial_files"
 },
 {
  "doc": "- if a `needs-check-do-not-pack` file is present, segments not known by\n  the index are marked for reindexing instead of deletion [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "check_unaligned"
 },
 {
  "doc": "- [unaligned] when `needs-check-do-not-pack` is present in the dataset\n  root directory, running a repack fails asking to run a check first,\n  to prevent deleting data that should be reindexed instead",
  "group": "arki_dataset_ondisk2_maintenance_vm2",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a directory [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_isdir"
 },
 {
  "doc": "- the size of each data file must match the data size exactly [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_datasize"
 },
 {
  "doc": "- the modification time of a directory segment can vary unpredictably,\n  so it is ignored. The modification time of the sequence file is used\n  instead.",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_ignore_dir_timestamp"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- segments that contain some data that has been removed are\n  identified as to be repacked [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_one_removed"
 },
 {
  "doc": "- segments that only contain data that has been removed are\n  identified as fully deleted [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_all_removed"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "fix_one_removed"
 },
 {
  "doc": "- [deleted] segments are left untouched",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "fix_deleted"
 },
 {
  "doc": "- [deleted] segments are removed from disk",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "repack_deleted"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "repack_one_removed"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "repack_archive"
 },
 {
  "doc": "- data files not known by the index are considered data files whose\n  entire content has been removed [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_new"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and creates a `needs-check-do-not-pack` file in the root of\n  the dataset.",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- while `needs-check-do-not-pack` is present, files with gaps are\n  marked for rescanning instead of repacking. This prevents a scenario\n  in which, after the index has been deleted, and some data has been\n  imported that got appended to an existing segment, that segment would\n  be considered as needing repack instead of rescan. [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_missing_index_rescan_partial_files"
 },
 {
  "doc": "- if a `needs-check-do-not-pack` file is present, segments not known by\n  the index are marked for reindexing instead of deletion [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "check_unaligned"
 },
 {
  "doc": "- [unaligned] when `needs-check-do-not-pack` is present in the dataset\n  root directory, running a repack fails asking to run a check first,\n  to prevent deleting data that should be reindexed instead",
  "group": "arki_dataset_ondisk2_maintenance_vm2_dirs",
  "method": "repack_unaligned"
 },
 {
  "doc": "- the segment must be a directory [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_isdir"
 },
 {
  "doc": "- the size of each data file must match the data size exactly [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_datasize"
 },
 {
  "doc": "- the modification time of a directory segment can vary unpredictably,\n  so it is ignored. The modification time of the sequence file is used\n  instead.",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_ignore_dir_timestamp"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "clean"
 },
 {
  "doc": "- the segment must exist [missing]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_exists"
 },
 {
  "doc": "- an empty segment not known by the index must be considered deleted [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_unknown_empty"
 },
 {
  "doc": "- segments that contain some data that has been removed are\n  identified as to be repacked [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_one_removed"
 },
 {
  "doc": "- segments that only contain data that has been removed are\n  identified as fully deleted [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_all_removed"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "fix_one_removed"
 },
 {
  "doc": "- [deleted] segments are left untouched",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "fix_deleted"
 },
 {
  "doc": "- [deleted] segments are removed from disk",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "repack_deleted"
 },
 {
  "doc": "",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "repack_one_removed"
 },
 {
  "doc": "- all data known by the index for this segment must be present on disk [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_dataexists"
 },
 {
  "doc": "- no pair of (offset, size) data spans from the index can overlap [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_data_overlap"
 },
 {
  "doc": "- data must start at the beginning of the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_hole_start"
 },
 {
  "doc": "- there must be no gaps between data in the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_hole_middle"
 },
 {
  "doc": "- data must end at the end of the segment [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_hole_end"
 },
 {
  "doc": "- find segments that can only contain data older than `archive age` days [archive_age]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_archive_age"
 },
 {
  "doc": "- find segments that can only contain data older than `delete age` days [delete_age]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_delete_age"
 },
 {
  "doc": "- the span of reference times in each segment must fit inside the interval\n  implied by the segment file name (FIXME: should this be disabled for\n  archives, to deal with datasets that had a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_metadata_reftimes_must_fit_segment"
 },
 {
  "doc": "- the segment name must represent an interval matching the dataset step\n  (FIXME: should this be disabled for archives, to deal with datasets that had\n  a change of step in their lifetime?) [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_segment_name_must_fit_step"
 },
 {
  "doc": "- data on disk must match the order of data used by queries [dirty]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_isordered"
 },
 {
  "doc": "- format-specific consistency checks on the content of each file must pass [corrupted]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "tcheck_corrupted_data"
 },
 {
  "doc": "- [dirty] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "fix_dirty"
 },
 {
  "doc": "- [unaligned] segments are imported in-place",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "fix_unaligned"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "fix_missing"
 },
 {
  "doc": "- [corrupted] segments can only be fixed by manual intervention. They\n  are reported and left untouched",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "fix_corrupted"
 },
 {
  "doc": "- [archive age] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "fix_archive_age"
 },
 {
  "doc": "- [delete age] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "fix_delete_age"
 },
 {
  "doc": "- [dirty] segments are rewritten to be without holes and have data in the right order.\n  In concat segments, this is done to guarantee linear disk access when\n  data are queried in the default sorting order. In dir segments, this\n  is done to avoid sequence numbers growing indefinitely for datasets\n  with frequent appends and removes.",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "repack_dirty"
 },
 {
  "doc": "- [missing] segments are removed from the index",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "repack_missing"
 },
 {
  "doc": "- [corrupted] segments are not touched",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "repack_corrupted"
 },
 {
  "doc": "- [archive age] segments are repacked if needed, then moved to .archive/last",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "repack_archive_age"
 },
 {
  "doc": "- [delete age] segments are deleted",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "repack_delete_age"
 },
 {
  "doc": "- [delete age] [dirty] a segment that needs to be both repacked and\n  deleted, gets deleted without repacking",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "repack_delete"
 },
 {
  "doc": "- [archive age] [dirty] a segment that needs to be both repacked and\n  archived, gets repacked before archiving",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "repack_archive"
 },
 {
  "doc": "- data files not known by the index are considered data files whose\n  entire content has been removed [deleted]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_new"
 },
 {
  "doc": "- if the index has been deleted, accessing the dataset recreates it\n  empty, and creates a `needs-check-do-not-pack` file in the root of\n  the dataset.",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_missing_index"
 },
 {
  "doc": "    ",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_missing_index_spurious_files"
 },
 {
  "doc": "- while `needs-check-do-not-pack` is present, files with gaps are\n  marked for rescanning instead of repacking. This prevents a scenario\n  in which, after the index has been deleted, and some data has been\n  imported that got appended to an existing segment, that segment would\n  be considered as needing repack instead of rescan. [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_missing_index_rescan_partial_files"
 },
 {
  "doc": "- if a `needs-check-do-not-pack` file is present, segments not known by\n  the index are marked for reindexing instead of deletion [unaligned]",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "check_unaligned"
 },
 {
  "doc": "- [unaligned] when `needs-check-do-not-pack` is present in the dataset\n  root directory, running a repack fails asking to run a check first,\n  to prevent deleting data that should be reindexed instead",
  "group": "arki_dataset_ondisk2_maintenance_odimh5",
  "method": "repack_unaligned"
 },
 {
  "doc": "",
  "group": "arki_dataset_outbound",
  "method": "import"
 },
 {
  "doc": "",
  "group": "arki_dataset_outbound",
  "method": "testacquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_offline",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_dataset_empty",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_dataset_empty",
  "method": "write"
 },
 {
  "doc": "",
  "group": "arki_dataset_fromfunction",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_dataset_testlarge",
  "method": "read"
 },
 {
  "doc": "",
  "group": "arki_dataset_merged",
  "method": "query"
 },
 {
  "doc": "",
  "group": "arki_dataset_gridquery",
  "method": "gridquery"
 },
 {
  "doc": "",
  "group": "arki_dataset_gridquery",
  "method": "no_expansion"
 },
 {
  "doc": "",
  "group": "arki_dataset_instantiate_simple",
  "method": "instantiate"
 },
 {
  "doc": "",
  "group": "arki_dataset_instantiate_ondisk2",
  "method": "instantiate"
 },
 {
  "doc": "",
  "group": "arki_dataset_instantiate_iseg",
  "method": "instantiate"
 },
 {
  "doc": "",
  "group": "arki_dataset_instantiate_error",
  "method": "instantiate"
 },
 {
  "doc": "",
  "group": "arki_dataset_instantiate_duplicates",
  "method": "instantiate"
 },
 {
  "doc": "",
  "group": "arki_dataset_instantiate_outbound",
  "method": "instantiate"
 },
 {
  "doc": "",
  "group": "arki_dataset_instantiate_discard",
  "method": "instantiate"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_ondisk2",
  "method": "querydata"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_ondisk2",
  "method": "querysummary"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_ondisk2",
  "method": "querybytes"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_ondisk2",
  "method": "query_data"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_ondisk2",
  "method": "query_inline"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_ondisk2",
  "method": "querybytes_integrity"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_ondisk2",
  "method": "postprocess"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_ondisk2",
  "method": "locked"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_ondisk2",
  "method": "interrupted_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_ondisk2",
  "method": "read_missing_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_ondisk2",
  "method": "issue116"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_plain",
  "method": "querydata"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_plain",
  "method": "querysummary"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_plain",
  "method": "querybytes"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_plain",
  "method": "query_data"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_plain",
  "method": "query_inline"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_plain",
  "method": "querybytes_integrity"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_plain",
  "method": "postprocess"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_plain",
  "method": "locked"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_plain",
  "method": "interrupted_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_plain",
  "method": "read_missing_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_plain",
  "method": "issue116"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_sqlite",
  "method": "querydata"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_sqlite",
  "method": "querysummary"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_sqlite",
  "method": "querybytes"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_sqlite",
  "method": "query_data"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_sqlite",
  "method": "query_inline"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_sqlite",
  "method": "querybytes_integrity"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_sqlite",
  "method": "postprocess"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_sqlite",
  "method": "locked"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_sqlite",
  "method": "interrupted_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_sqlite",
  "method": "read_missing_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_simple_sqlite",
  "method": "issue116"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_iseg",
  "method": "querydata"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_iseg",
  "method": "querysummary"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_iseg",
  "method": "querybytes"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_iseg",
  "method": "query_data"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_iseg",
  "method": "query_inline"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_iseg",
  "method": "querybytes_integrity"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_iseg",
  "method": "postprocess"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_iseg",
  "method": "locked"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_iseg",
  "method": "interrupted_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_iseg",
  "method": "read_missing_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_grib_iseg",
  "method": "issue116"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_ondisk2",
  "method": "querydata"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_ondisk2",
  "method": "querysummary"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_ondisk2",
  "method": "querybytes"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_ondisk2",
  "method": "query_data"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_ondisk2",
  "method": "query_inline"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_ondisk2",
  "method": "querybytes_integrity"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_ondisk2",
  "method": "postprocess"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_ondisk2",
  "method": "locked"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_ondisk2",
  "method": "interrupted_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_ondisk2",
  "method": "read_missing_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_ondisk2",
  "method": "issue116"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_plain",
  "method": "querydata"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_plain",
  "method": "querysummary"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_plain",
  "method": "querybytes"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_plain",
  "method": "query_data"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_plain",
  "method": "query_inline"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_plain",
  "method": "querybytes_integrity"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_plain",
  "method": "postprocess"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_plain",
  "method": "locked"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_plain",
  "method": "interrupted_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_plain",
  "method": "read_missing_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_plain",
  "method": "issue116"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_sqlite",
  "method": "querydata"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_sqlite",
  "method": "querysummary"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_sqlite",
  "method": "querybytes"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_sqlite",
  "method": "query_data"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_sqlite",
  "method": "query_inline"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_sqlite",
  "method": "querybytes_integrity"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_sqlite",
  "method": "postprocess"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_sqlite",
  "method": "locked"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_sqlite",
  "method": "interrupted_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_sqlite",
  "method": "read_missing_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_simple_sqlite",
  "method": "issue116"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_iseg",
  "method": "querydata"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_iseg",
  "method": "querysummary"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_iseg",
  "method": "querybytes"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_iseg",
  "method": "query_data"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_iseg",
  "method": "query_inline"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_iseg",
  "method": "querybytes_integrity"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_iseg",
  "method": "postprocess"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_iseg",
  "method": "locked"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_iseg",
  "method": "interrupted_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_iseg",
  "method": "read_missing_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_bufr_iseg",
  "method": "issue116"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_ondisk2",
  "method": "querydata"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_ondisk2",
  "method": "querysummary"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_ondisk2",
  "method": "querybytes"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_ondisk2",
  "method": "query_data"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_ondisk2",
  "method": "query_inline"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_ondisk2",
  "method": "querybytes_integrity"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_ondisk2",
  "method": "postprocess"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_ondisk2",
  "method": "locked"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_ondisk2",
  "method": "interrupted_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_ondisk2",
  "method": "read_missing_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_ondisk2",
  "method": "issue116"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_plain",
  "method": "querydata"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_plain",
  "method": "querysummary"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_plain",
  "method": "querybytes"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_plain",
  "method": "query_data"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_plain",
  "method": "query_inline"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_plain",
  "method": "querybytes_integrity"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_plain",
  "method": "postprocess"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_plain",
  "method": "locked"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_plain",
  "method": "interrupted_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_plain",
  "method": "read_missing_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_plain",
  "method": "issue116"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_sqlite",
  "method": "querydata"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_sqlite",
  "method": "querysummary"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_sqlite",
  "method": "querybytes"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_sqlite",
  "method": "query_data"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_sqlite",
  "method": "query_inline"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_sqlite",
  "method": "querybytes_integrity"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_sqlite",
  "method": "postprocess"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_sqlite",
  "method": "locked"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_sqlite",
  "method": "interrupted_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_sqlite",
  "method": "read_missing_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_simple_sqlite",
  "method": "issue116"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_iseg",
  "method": "querydata"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_iseg",
  "method": "querysummary"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_iseg",
  "method": "querybytes"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_iseg",
  "method": "query_data"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_iseg",
  "method": "query_inline"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_iseg",
  "method": "querybytes_integrity"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_iseg",
  "method": "postprocess"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_iseg",
  "method": "locked"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_iseg",
  "method": "interrupted_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_iseg",
  "method": "read_missing_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_vm2_iseg",
  "method": "issue116"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_ondisk2",
  "method": "querydata"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_ondisk2",
  "method": "querysummary"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_ondisk2",
  "method": "querybytes"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_ondisk2",
  "method": "query_data"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_ondisk2",
  "method": "query_inline"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_ondisk2",
  "method": "querybytes_integrity"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_ondisk2",
  "method": "postprocess"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_ondisk2",
  "method": "locked"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_ondisk2",
  "method": "interrupted_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_ondisk2",
  "method": "read_missing_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_ondisk2",
  "method": "issue116"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_plain",
  "method": "querydata"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_plain",
  "method": "querysummary"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_plain",
  "method": "querybytes"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_plain",
  "method": "query_data"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_plain",
  "method": "query_inline"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_plain",
  "method": "querybytes_integrity"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_plain",
  "method": "postprocess"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_plain",
  "method": "locked"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_plain",
  "method": "interrupted_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_plain",
  "method": "read_missing_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_plain",
  "method": "issue116"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_sqlite",
  "method": "querydata"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_sqlite",
  "method": "querysummary"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_sqlite",
  "method": "querybytes"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_sqlite",
  "method": "query_data"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_sqlite",
  "method": "query_inline"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_sqlite",
  "method": "querybytes_integrity"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_sqlite",
  "method": "postprocess"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_sqlite",
  "method": "locked"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_sqlite",
  "method": "interrupted_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_sqlite",
  "method": "read_missing_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_simple_sqlite",
  "method": "issue116"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_iseg",
  "method": "querydata"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_iseg",
  "method": "querysummary"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_iseg",
  "method": "querybytes"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_iseg",
  "method": "query_data"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_iseg",
  "method": "query_inline"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_iseg",
  "method": "querybytes_integrity"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_iseg",
  "method": "postprocess"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_iseg",
  "method": "locked"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_iseg",
  "method": "interrupted_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_iseg",
  "method": "read_missing_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_reader_odim_iseg",
  "method": "issue116"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_ondisk2",
  "method": "import_largefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_ondisk2",
  "method": "import_batch_replace_usn"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_simple_plain",
  "method": "import_largefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_simple_plain",
  "method": "import_batch_replace_usn"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_simple_sqlite",
  "method": "import_largefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_simple_sqlite",
  "method": "import_batch_replace_usn"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_iseg",
  "method": "import_largefile"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_iseg",
  "method": "import_batch_replace_usn"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_ondisk2",
  "method": "import"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_ondisk2",
  "method": "import_error"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_ondisk2",
  "method": "import_batch_replace_never"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_ondisk2",
  "method": "import_batch_replace_always"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_ondisk2",
  "method": "import_before_archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_ondisk2",
  "method": "import_before_delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_ondisk2",
  "method": "second_resolution"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_ondisk2",
  "method": "transaction_same_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_ondisk2",
  "method": "transaction_same_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_ondisk2",
  "method": "transaction_same_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_ondisk2",
  "method": "transaction_different_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_ondisk2",
  "method": "transaction_different_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_ondisk2",
  "method": "transaction_different_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_ondisk2",
  "method": "test_acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_plain",
  "method": "import"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_plain",
  "method": "import_error"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_plain",
  "method": "import_batch_replace_never"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_plain",
  "method": "import_batch_replace_always"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_plain",
  "method": "import_before_archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_plain",
  "method": "import_before_delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_plain",
  "method": "second_resolution"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_plain",
  "method": "transaction_same_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_plain",
  "method": "transaction_same_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_plain",
  "method": "transaction_same_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_plain",
  "method": "transaction_different_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_plain",
  "method": "transaction_different_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_plain",
  "method": "transaction_different_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_plain",
  "method": "test_acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_sqlite",
  "method": "import"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_sqlite",
  "method": "import_error"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_sqlite",
  "method": "import_batch_replace_never"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_sqlite",
  "method": "import_batch_replace_always"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_sqlite",
  "method": "import_before_archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_sqlite",
  "method": "import_before_delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_sqlite",
  "method": "second_resolution"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_sqlite",
  "method": "transaction_same_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_sqlite",
  "method": "transaction_same_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_sqlite",
  "method": "transaction_same_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_sqlite",
  "method": "transaction_different_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_sqlite",
  "method": "transaction_different_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_sqlite",
  "method": "transaction_different_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_simple_sqlite",
  "method": "test_acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_iseg",
  "method": "import"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_iseg",
  "method": "import_error"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_iseg",
  "method": "import_batch_replace_never"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_iseg",
  "method": "import_batch_replace_always"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_iseg",
  "method": "import_before_archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_iseg",
  "method": "import_before_delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_iseg",
  "method": "second_resolution"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_iseg",
  "method": "transaction_same_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_iseg",
  "method": "transaction_same_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_iseg",
  "method": "transaction_same_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_iseg",
  "method": "transaction_different_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_iseg",
  "method": "transaction_different_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_iseg",
  "method": "transaction_different_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_grib_iseg",
  "method": "test_acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_ondisk2",
  "method": "import"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_ondisk2",
  "method": "import_error"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_ondisk2",
  "method": "import_batch_replace_never"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_ondisk2",
  "method": "import_batch_replace_always"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_ondisk2",
  "method": "import_before_archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_ondisk2",
  "method": "import_before_delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_ondisk2",
  "method": "second_resolution"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_ondisk2",
  "method": "transaction_same_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_ondisk2",
  "method": "transaction_same_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_ondisk2",
  "method": "transaction_same_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_ondisk2",
  "method": "transaction_different_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_ondisk2",
  "method": "transaction_different_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_ondisk2",
  "method": "transaction_different_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_ondisk2",
  "method": "test_acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_plain",
  "method": "import"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_plain",
  "method": "import_error"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_plain",
  "method": "import_batch_replace_never"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_plain",
  "method": "import_batch_replace_always"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_plain",
  "method": "import_before_archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_plain",
  "method": "import_before_delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_plain",
  "method": "second_resolution"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_plain",
  "method": "transaction_same_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_plain",
  "method": "transaction_same_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_plain",
  "method": "transaction_same_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_plain",
  "method": "transaction_different_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_plain",
  "method": "transaction_different_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_plain",
  "method": "transaction_different_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_plain",
  "method": "test_acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_sqlite",
  "method": "import"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_sqlite",
  "method": "import_error"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_sqlite",
  "method": "import_batch_replace_never"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_sqlite",
  "method": "import_batch_replace_always"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_sqlite",
  "method": "import_before_archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_sqlite",
  "method": "import_before_delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_sqlite",
  "method": "second_resolution"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_sqlite",
  "method": "transaction_same_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_sqlite",
  "method": "transaction_same_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_sqlite",
  "method": "transaction_same_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_sqlite",
  "method": "transaction_different_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_sqlite",
  "method": "transaction_different_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_sqlite",
  "method": "transaction_different_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_simple_sqlite",
  "method": "test_acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_iseg",
  "method": "import"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_iseg",
  "method": "import_error"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_iseg",
  "method": "import_batch_replace_never"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_iseg",
  "method": "import_batch_replace_always"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_iseg",
  "method": "import_before_archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_iseg",
  "method": "import_before_delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_iseg",
  "method": "second_resolution"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_iseg",
  "method": "transaction_same_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_iseg",
  "method": "transaction_same_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_iseg",
  "method": "transaction_same_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_iseg",
  "method": "transaction_different_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_iseg",
  "method": "transaction_different_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_iseg",
  "method": "transaction_different_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_bufr_iseg",
  "method": "test_acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_ondisk2",
  "method": "import"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_ondisk2",
  "method": "import_error"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_ondisk2",
  "method": "import_batch_replace_never"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_ondisk2",
  "method": "import_batch_replace_always"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_ondisk2",
  "method": "import_before_archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_ondisk2",
  "method": "import_before_delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_ondisk2",
  "method": "second_resolution"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_ondisk2",
  "method": "transaction_same_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_ondisk2",
  "method": "transaction_same_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_ondisk2",
  "method": "transaction_same_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_ondisk2",
  "method": "transaction_different_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_ondisk2",
  "method": "transaction_different_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_ondisk2",
  "method": "transaction_different_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_ondisk2",
  "method": "test_acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_plain",
  "method": "import"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_plain",
  "method": "import_error"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_plain",
  "method": "import_batch_replace_never"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_plain",
  "method": "import_batch_replace_always"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_plain",
  "method": "import_before_archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_plain",
  "method": "import_before_delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_plain",
  "method": "second_resolution"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_plain",
  "method": "transaction_same_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_plain",
  "method": "transaction_same_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_plain",
  "method": "transaction_same_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_plain",
  "method": "transaction_different_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_plain",
  "method": "transaction_different_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_plain",
  "method": "transaction_different_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_plain",
  "method": "test_acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_sqlite",
  "method": "import"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_sqlite",
  "method": "import_error"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_sqlite",
  "method": "import_batch_replace_never"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_sqlite",
  "method": "import_batch_replace_always"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_sqlite",
  "method": "import_before_archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_sqlite",
  "method": "import_before_delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_sqlite",
  "method": "second_resolution"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_sqlite",
  "method": "transaction_same_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_sqlite",
  "method": "transaction_same_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_sqlite",
  "method": "transaction_same_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_sqlite",
  "method": "transaction_different_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_sqlite",
  "method": "transaction_different_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_sqlite",
  "method": "transaction_different_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_simple_sqlite",
  "method": "test_acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_iseg",
  "method": "import"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_iseg",
  "method": "import_error"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_iseg",
  "method": "import_batch_replace_never"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_iseg",
  "method": "import_batch_replace_always"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_iseg",
  "method": "import_before_archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_iseg",
  "method": "import_before_delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_iseg",
  "method": "second_resolution"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_iseg",
  "method": "transaction_same_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_iseg",
  "method": "transaction_same_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_iseg",
  "method": "transaction_same_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_iseg",
  "method": "transaction_different_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_iseg",
  "method": "transaction_different_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_iseg",
  "method": "transaction_different_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_vm2_iseg",
  "method": "test_acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_ondisk2",
  "method": "import"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_ondisk2",
  "method": "import_error"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_ondisk2",
  "method": "import_batch_replace_never"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_ondisk2",
  "method": "import_batch_replace_always"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_ondisk2",
  "method": "import_before_archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_ondisk2",
  "method": "import_before_delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_ondisk2",
  "method": "second_resolution"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_ondisk2",
  "method": "transaction_same_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_ondisk2",
  "method": "transaction_same_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_ondisk2",
  "method": "transaction_same_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_ondisk2",
  "method": "transaction_different_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_ondisk2",
  "method": "transaction_different_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_ondisk2",
  "method": "transaction_different_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_ondisk2",
  "method": "test_acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_plain",
  "method": "import"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_plain",
  "method": "import_error"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_plain",
  "method": "import_batch_replace_never"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_plain",
  "method": "import_batch_replace_always"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_plain",
  "method": "import_before_archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_plain",
  "method": "import_before_delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_plain",
  "method": "second_resolution"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_plain",
  "method": "transaction_same_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_plain",
  "method": "transaction_same_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_plain",
  "method": "transaction_same_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_plain",
  "method": "transaction_different_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_plain",
  "method": "transaction_different_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_plain",
  "method": "transaction_different_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_plain",
  "method": "test_acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_sqlite",
  "method": "import"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_sqlite",
  "method": "import_error"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_sqlite",
  "method": "import_batch_replace_never"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_sqlite",
  "method": "import_batch_replace_always"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_sqlite",
  "method": "import_before_archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_sqlite",
  "method": "import_before_delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_sqlite",
  "method": "second_resolution"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_sqlite",
  "method": "transaction_same_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_sqlite",
  "method": "transaction_same_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_sqlite",
  "method": "transaction_same_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_sqlite",
  "method": "transaction_different_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_sqlite",
  "method": "transaction_different_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_sqlite",
  "method": "transaction_different_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_simple_sqlite",
  "method": "test_acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_iseg",
  "method": "import"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_iseg",
  "method": "import_error"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_iseg",
  "method": "import_batch_replace_never"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_iseg",
  "method": "import_batch_replace_always"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_iseg",
  "method": "import_before_archive_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_iseg",
  "method": "import_before_delete_age"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_iseg",
  "method": "second_resolution"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_iseg",
  "method": "transaction_same_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_iseg",
  "method": "transaction_same_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_iseg",
  "method": "transaction_same_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_iseg",
  "method": "transaction_different_segment_fail_first"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_iseg",
  "method": "transaction_different_segment_fail_middle"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_iseg",
  "method": "transaction_different_segment_fail_last"
 },
 {
  "doc": "",
  "group": "arki_dataset_writer_odim_iseg",
  "method": "test_acquire"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_ondisk2",
  "method": "preconditions"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_ondisk2",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_ondisk2",
  "method": "check_archives"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_ondisk2",
  "method": "check_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_ondisk2",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_ondisk2",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_ondisk2",
  "method": "check_issue51"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_simple_plain",
  "method": "preconditions"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_simple_plain",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_simple_plain",
  "method": "check_archives"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_simple_plain",
  "method": "check_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_simple_plain",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_simple_plain",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_simple_plain",
  "method": "check_issue51"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_simple_sqlite",
  "method": "preconditions"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_simple_sqlite",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_simple_sqlite",
  "method": "check_archives"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_simple_sqlite",
  "method": "check_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_simple_sqlite",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_simple_sqlite",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_simple_sqlite",
  "method": "check_issue51"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_iseg",
  "method": "preconditions"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_iseg",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_iseg",
  "method": "check_archives"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_iseg",
  "method": "check_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_iseg",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_iseg",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_grib_iseg",
  "method": "check_issue51"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_ondisk2",
  "method": "preconditions"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_ondisk2",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_ondisk2",
  "method": "check_archives"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_ondisk2",
  "method": "check_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_ondisk2",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_ondisk2",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_ondisk2",
  "method": "check_issue51"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_simple_plain",
  "method": "preconditions"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_simple_plain",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_simple_plain",
  "method": "check_archives"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_simple_plain",
  "method": "check_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_simple_plain",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_simple_plain",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_simple_plain",
  "method": "check_issue51"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_simple_sqlite",
  "method": "preconditions"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_simple_sqlite",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_simple_sqlite",
  "method": "check_archives"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_simple_sqlite",
  "method": "check_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_simple_sqlite",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_simple_sqlite",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_simple_sqlite",
  "method": "check_issue51"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_iseg",
  "method": "preconditions"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_iseg",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_iseg",
  "method": "check_archives"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_iseg",
  "method": "check_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_iseg",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_iseg",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_bufr_iseg",
  "method": "check_issue51"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_ondisk2",
  "method": "preconditions"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_ondisk2",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_ondisk2",
  "method": "check_archives"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_ondisk2",
  "method": "check_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_ondisk2",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_ondisk2",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_ondisk2",
  "method": "check_issue51"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_simple_plain",
  "method": "preconditions"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_simple_plain",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_simple_plain",
  "method": "check_archives"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_simple_plain",
  "method": "check_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_simple_plain",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_simple_plain",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_simple_plain",
  "method": "check_issue51"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_simple_sqlite",
  "method": "preconditions"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_simple_sqlite",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_simple_sqlite",
  "method": "check_archives"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_simple_sqlite",
  "method": "check_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_simple_sqlite",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_simple_sqlite",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_simple_sqlite",
  "method": "check_issue51"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_iseg",
  "method": "preconditions"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_iseg",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_iseg",
  "method": "check_archives"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_iseg",
  "method": "check_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_iseg",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_iseg",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_vm2_iseg",
  "method": "check_issue51"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_ondisk2",
  "method": "preconditions"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_ondisk2",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_ondisk2",
  "method": "check_archives"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_ondisk2",
  "method": "check_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_ondisk2",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_ondisk2",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_ondisk2",
  "method": "check_issue51"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_simple_plain",
  "method": "preconditions"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_simple_plain",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_simple_plain",
  "method": "check_archives"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_simple_plain",
  "method": "check_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_simple_plain",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_simple_plain",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_simple_plain",
  "method": "check_issue51"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_simple_sqlite",
  "method": "preconditions"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_simple_sqlite",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_simple_sqlite",
  "method": "check_archives"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_simple_sqlite",
  "method": "check_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_simple_sqlite",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_simple_sqlite",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_simple_sqlite",
  "method": "check_issue51"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_iseg",
  "method": "preconditions"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_iseg",
  "method": "check"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_iseg",
  "method": "check_archives"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_iseg",
  "method": "check_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_iseg",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_iseg",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_dataset_checker_odim_iseg",
  "method": "check_issue51"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_ondisk2",
  "method": "read_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_ondisk2",
  "method": "read_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_ondisk2",
  "method": "read_write1"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_ondisk2",
  "method": "write_write_same_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_ondisk2",
  "method": "write_write_different_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_ondisk2",
  "method": "read_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_ondisk2",
  "method": "write_check"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_ondisk2",
  "method": "read_repack2"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_ondisk2",
  "method": "write_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_ondisk2",
  "method": "nolock_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_ondisk2",
  "method": "nolock_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_ondisk2",
  "method": "nolock_rescan"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_ondisk2",
  "method": "nolock_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_plain",
  "method": "read_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_plain",
  "method": "read_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_plain",
  "method": "read_write1"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_plain",
  "method": "write_write_same_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_plain",
  "method": "write_write_different_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_plain",
  "method": "read_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_plain",
  "method": "write_check"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_plain",
  "method": "read_repack2"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_plain",
  "method": "write_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_plain",
  "method": "nolock_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_plain",
  "method": "nolock_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_plain",
  "method": "nolock_rescan"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_plain",
  "method": "nolock_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_sqlite",
  "method": "read_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_sqlite",
  "method": "read_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_sqlite",
  "method": "read_write1"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_sqlite",
  "method": "write_write_same_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_sqlite",
  "method": "write_write_different_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_sqlite",
  "method": "read_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_sqlite",
  "method": "write_check"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_sqlite",
  "method": "read_repack2"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_sqlite",
  "method": "write_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_sqlite",
  "method": "nolock_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_sqlite",
  "method": "nolock_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_sqlite",
  "method": "nolock_rescan"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_simple_sqlite",
  "method": "nolock_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_iseg",
  "method": "read_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_iseg",
  "method": "read_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_iseg",
  "method": "read_write1"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_iseg",
  "method": "write_write_same_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_iseg",
  "method": "write_write_different_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_iseg",
  "method": "read_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_iseg",
  "method": "write_check"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_iseg",
  "method": "read_repack2"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_iseg",
  "method": "write_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_iseg",
  "method": "nolock_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_iseg",
  "method": "nolock_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_iseg",
  "method": "nolock_rescan"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_grib_iseg",
  "method": "nolock_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_ondisk2",
  "method": "read_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_ondisk2",
  "method": "read_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_ondisk2",
  "method": "read_write1"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_ondisk2",
  "method": "write_write_same_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_ondisk2",
  "method": "write_write_different_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_ondisk2",
  "method": "read_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_ondisk2",
  "method": "write_check"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_ondisk2",
  "method": "read_repack2"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_ondisk2",
  "method": "write_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_ondisk2",
  "method": "nolock_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_ondisk2",
  "method": "nolock_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_ondisk2",
  "method": "nolock_rescan"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_ondisk2",
  "method": "nolock_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_plain",
  "method": "read_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_plain",
  "method": "read_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_plain",
  "method": "read_write1"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_plain",
  "method": "write_write_same_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_plain",
  "method": "write_write_different_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_plain",
  "method": "read_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_plain",
  "method": "write_check"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_plain",
  "method": "read_repack2"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_plain",
  "method": "write_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_plain",
  "method": "nolock_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_plain",
  "method": "nolock_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_plain",
  "method": "nolock_rescan"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_plain",
  "method": "nolock_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_sqlite",
  "method": "read_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_sqlite",
  "method": "read_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_sqlite",
  "method": "read_write1"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_sqlite",
  "method": "write_write_same_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_sqlite",
  "method": "write_write_different_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_sqlite",
  "method": "read_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_sqlite",
  "method": "write_check"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_sqlite",
  "method": "read_repack2"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_sqlite",
  "method": "write_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_sqlite",
  "method": "nolock_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_sqlite",
  "method": "nolock_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_sqlite",
  "method": "nolock_rescan"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_simple_sqlite",
  "method": "nolock_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_iseg",
  "method": "read_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_iseg",
  "method": "read_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_iseg",
  "method": "read_write1"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_iseg",
  "method": "write_write_same_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_iseg",
  "method": "write_write_different_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_iseg",
  "method": "read_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_iseg",
  "method": "write_check"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_iseg",
  "method": "read_repack2"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_iseg",
  "method": "write_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_iseg",
  "method": "nolock_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_iseg",
  "method": "nolock_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_iseg",
  "method": "nolock_rescan"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_bufr_iseg",
  "method": "nolock_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_ondisk2",
  "method": "read_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_ondisk2",
  "method": "read_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_ondisk2",
  "method": "read_write1"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_ondisk2",
  "method": "write_write_same_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_ondisk2",
  "method": "write_write_different_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_ondisk2",
  "method": "read_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_ondisk2",
  "method": "write_check"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_ondisk2",
  "method": "read_repack2"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_ondisk2",
  "method": "write_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_ondisk2",
  "method": "nolock_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_ondisk2",
  "method": "nolock_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_ondisk2",
  "method": "nolock_rescan"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_ondisk2",
  "method": "nolock_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_plain",
  "method": "read_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_plain",
  "method": "read_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_plain",
  "method": "read_write1"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_plain",
  "method": "write_write_same_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_plain",
  "method": "write_write_different_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_plain",
  "method": "read_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_plain",
  "method": "write_check"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_plain",
  "method": "read_repack2"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_plain",
  "method": "write_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_plain",
  "method": "nolock_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_plain",
  "method": "nolock_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_plain",
  "method": "nolock_rescan"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_plain",
  "method": "nolock_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_sqlite",
  "method": "read_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_sqlite",
  "method": "read_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_sqlite",
  "method": "read_write1"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_sqlite",
  "method": "write_write_same_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_sqlite",
  "method": "write_write_different_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_sqlite",
  "method": "read_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_sqlite",
  "method": "write_check"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_sqlite",
  "method": "read_repack2"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_sqlite",
  "method": "write_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_sqlite",
  "method": "nolock_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_sqlite",
  "method": "nolock_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_sqlite",
  "method": "nolock_rescan"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_simple_sqlite",
  "method": "nolock_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_iseg",
  "method": "read_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_iseg",
  "method": "read_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_iseg",
  "method": "read_write1"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_iseg",
  "method": "write_write_same_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_iseg",
  "method": "write_write_different_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_iseg",
  "method": "read_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_iseg",
  "method": "write_check"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_iseg",
  "method": "read_repack2"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_iseg",
  "method": "write_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_iseg",
  "method": "nolock_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_iseg",
  "method": "nolock_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_iseg",
  "method": "nolock_rescan"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_vm2_iseg",
  "method": "nolock_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_ondisk2",
  "method": "read_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_ondisk2",
  "method": "read_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_ondisk2",
  "method": "read_write1"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_ondisk2",
  "method": "write_write_same_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_ondisk2",
  "method": "write_write_different_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_ondisk2",
  "method": "read_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_ondisk2",
  "method": "write_check"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_ondisk2",
  "method": "read_repack2"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_ondisk2",
  "method": "write_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_ondisk2",
  "method": "nolock_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_ondisk2",
  "method": "nolock_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_ondisk2",
  "method": "nolock_rescan"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_ondisk2",
  "method": "nolock_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_plain",
  "method": "read_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_plain",
  "method": "read_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_plain",
  "method": "read_write1"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_plain",
  "method": "write_write_same_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_plain",
  "method": "write_write_different_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_plain",
  "method": "read_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_plain",
  "method": "write_check"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_plain",
  "method": "read_repack2"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_plain",
  "method": "write_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_plain",
  "method": "nolock_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_plain",
  "method": "nolock_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_plain",
  "method": "nolock_rescan"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_plain",
  "method": "nolock_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_sqlite",
  "method": "read_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_sqlite",
  "method": "read_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_sqlite",
  "method": "read_write1"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_sqlite",
  "method": "write_write_same_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_sqlite",
  "method": "write_write_different_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_sqlite",
  "method": "read_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_sqlite",
  "method": "write_check"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_sqlite",
  "method": "read_repack2"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_sqlite",
  "method": "write_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_sqlite",
  "method": "nolock_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_sqlite",
  "method": "nolock_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_sqlite",
  "method": "nolock_rescan"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_simple_sqlite",
  "method": "nolock_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_iseg",
  "method": "read_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_iseg",
  "method": "read_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_iseg",
  "method": "read_write1"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_iseg",
  "method": "write_write_same_segment"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_iseg",
  "method": "write_write_different_segments"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_iseg",
  "method": "read_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_iseg",
  "method": "write_check"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_iseg",
  "method": "read_repack2"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_iseg",
  "method": "write_repack"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_iseg",
  "method": "nolock_read"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_iseg",
  "method": "nolock_write"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_iseg",
  "method": "nolock_rescan"
 },
 {
  "doc": "",
  "group": "arki_dataset_concurrent_odim_iseg",
  "method": "nolock_repack"
 },
 {
  "doc": "",
  "group": "arki_metadatagrid",
  "method": "query"
 },
 {
  "doc": "",
  "group": "arki_postprocess",
  "method": "null_validate"
 },
 {
  "doc": "",
  "group": "arki_postprocess",
  "method": "null"
 },
 {
  "doc": "",
  "group": "arki_postprocess",
  "method": "countbytes"
 },
 {
  "doc": "",
  "group": "arki_postprocess",
  "method": "cat"
 },
 {
  "doc": "",
  "group": "arki_postprocess",
  "method": "countbytes_large"
 },
 {
  "doc": "",
  "group": "arki_postprocess",
  "method": "zeroes_arg"
 },
 {
  "doc": "",
  "group": "arki_postprocess",
  "method": "zeroes_arg_large"
 },
 {
  "doc": "",
  "group": "arki_querymacro",
  "method": "count"
 },
 {
  "doc": "",
  "group": "arki_querymacro",
  "method": "noop"
 },
 {
  "doc": "",
  "group": "arki_querymacro",
  "method": "noopcopy"
 },
 {
  "doc": "",
  "group": "arki_querymacro",
  "method": "expa"
 },
 {
  "doc": "",
  "group": "arki_querymacro",
  "method": "expa_arg"
 },
 {
  "doc": "",
  "group": "arki_querymacro",
  "method": "gridspace"
 },
 {
  "doc": "",
  "group": "arki_querymacro",
  "method": "expa_inline"
 },
 {
  "doc": "",
  "group": "arki_querymacro",
  "method": "expa_sort"
 },
 {
  "doc": "",
  "group": "arki_dataset_datasets",
  "method": "instantiate"
 },
 {
  "doc": "",
  "group": "arki_dispatcher",
  "method": "simple"
 },
 {
  "doc": "",
  "group": "arki_dispatcher",
  "method": "drop_cached_data"
 },
 {
  "doc": "",
  "group": "arki_dispatcher",
  "method": "regression01"
 },
 {
  "doc": "",
  "group": "arki_dispatcher",
  "method": "validation"
 },
 {
  "doc": "",
  "group": "arki_dispatcher",
  "method": "missing_reftime"
 },
 {
  "doc": "",
  "group": "arki_runtime_processor",
  "method": "metadata_binary"
 },
 {
  "doc": "",
  "group": "arki_runtime_processor",
  "method": "metadata_binary_inline"
 },
 {
  "doc": "",
  "group": "arki_runtime_processor",
  "method": "data_binary"
 },
 {
  "doc": "",
  "group": "arki_runtime_source",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_runtime_dispatch",
  "method": "empty"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkiquery",
  "method": "postproc"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkiquery",
  "method": "query_metadata"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkiquery",
  "method": "query_merged"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkiquery",
  "method": "query_qmacro"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkiquery",
  "method": "query_stdin"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_ondisk2",
  "method": "clean"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_ondisk2",
  "method": "clean_filtered"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_ondisk2",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_ondisk2",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_ondisk2",
  "method": "archive"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_ondisk2",
  "method": "issue57"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_ondisk2",
  "method": "tar"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_ondisk2",
  "method": "zip"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_ondisk2",
  "method": "compress"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_ondisk2",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_ondisk2",
  "method": "remove_old"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_ondisk2",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_plain",
  "method": "clean"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_plain",
  "method": "clean_filtered"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_plain",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_plain",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_plain",
  "method": "archive"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_plain",
  "method": "issue57"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_plain",
  "method": "tar"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_plain",
  "method": "zip"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_plain",
  "method": "compress"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_plain",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_plain",
  "method": "remove_old"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_plain",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_sqlite",
  "method": "clean"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_sqlite",
  "method": "clean_filtered"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_sqlite",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_sqlite",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_sqlite",
  "method": "archive"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_sqlite",
  "method": "issue57"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_sqlite",
  "method": "tar"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_sqlite",
  "method": "zip"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_sqlite",
  "method": "compress"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_sqlite",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_sqlite",
  "method": "remove_old"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_simple_sqlite",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_iseg",
  "method": "clean"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_iseg",
  "method": "clean_filtered"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_iseg",
  "method": "remove_all"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_iseg",
  "method": "remove_all_filtered"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_iseg",
  "method": "archive"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_iseg",
  "method": "issue57"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_iseg",
  "method": "tar"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_iseg",
  "method": "zip"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_iseg",
  "method": "compress"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_iseg",
  "method": "scan"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_iseg",
  "method": "remove_old"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkicheck_iseg",
  "method": "remove"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkiscan",
  "method": "scan_stdin"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkiscan",
  "method": "scan_grib"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkiscan",
  "method": "scan_bufr"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkiscan",
  "method": "scan_bufr_multiple"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkiscan",
  "method": "scan_metadata"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkiscan",
  "method": "scan_stdin"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkiscan",
  "method": "dispatch_plain"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkiscan",
  "method": "dispatch_copyok"
 },
 {
  "doc": "",
  "group": "arki_runtime_arkiscan",
  "method": "dispatch_issue68"
 },
 {
  "doc": "",
  "group": "arki_runtime",
  "method": "files"
 },
 {
  "doc": "",
  "group": "arki_dataset_http",
  "method": "allsameremoteserver"
 },
 {
  "doc": "",
  "group": "arki_report",
  "method": "simple"
 },
 {
  "doc": "",
  "group": "arki_report",
  "method": "regression"
 }
]