#ifndef ARKI_DATASET_STEP_H
#define ARKI_DATASET_STEP_H

/// Compute names for segments in an arkimet dataset

#include <string>
#include <vector>
#include <memory>
#include <functional>
#include "arki/matcher.h"

namespace arki {

namespace utils {
struct Regexp;
}

namespace core {
class Time;
}

namespace types {
class Reftime;
namespace reftime {
class Period;
}
}

class Matcher;
namespace matcher {
class OR;
}

namespace dataset {

namespace step {

struct Files;

/**
 * Parameters used to match segments
 */
struct SegmentQuery
{
    std::string root;
    std::string format;
    std::string extension_re = "(\\.zip|\\.gz|\\.tar|)$";
    Matcher matcher;

    SegmentQuery();
    SegmentQuery(const std::string& root, const std::string& format);
    SegmentQuery(const std::string& root, const std::string& format, const Matcher& matcher);
    SegmentQuery(const std::string& root, const std::string& format, const std::string& extension_re, const Matcher& matcher);
};

/**
 * Encapsulate a directory containing segment directories, and allow querying
 * them by date
 */
class Dirs
{
public:
    const SegmentQuery& query;

    Dirs(const SegmentQuery& query);

    /**
     * Generate all the matching file-containing directories under this one.
     */
    virtual void list(std::function<void(std::unique_ptr<Files>)> dest) const = 0;

    /**
     * Return the Reftime periods of the first and last segment under this
     * directory.
     */
    virtual void extremes(core::Interval& first, core::Interval& last) const = 0;
};

/**
 * Encapsulate a directory containing segments, and allow querying them by date
 */
class Files
{
protected:
    const Dirs& dirs;
    std::string relpath;
    int value;

public:
    Files(const Dirs& dirs, const std::string& relpath, int value);

    /**
     * List all matching segments in this directory, with paths relative to dirs.root
     */
    virtual void list(std::function<void(std::string&& relpath)> dest) const = 0;

    /**
     * Return the first segment in this directory, with path relative to dirs.root
     */
    virtual core::Interval first() const = 0;

    /**
     * Return the last segment in this directory, with path relative to dirs.root
     */
    virtual core::Interval last() const = 0;
};

}

/**
 * Generator for filenames the dataset in which to store a metadata
 */
struct Step
{
    virtual ~Step() {}
    virtual std::string operator()(const core::Time& time) const = 0;

    /**
     * Instantiate a step::Dirs to query segments for the given directory and format
     */
    virtual std::unique_ptr<step::Dirs> explore(const step::SegmentQuery& query) const = 0;

    /**
     * Get the timespan of a file by just looking at its path.
     *
     * Returns true if the path could be recognised, and false if it does not
     * look like path has been generated by this Step.
     */
    virtual bool path_timespan(const std::string& path, core::Time& start_time, core::Time& end_time) const = 0;

    /**
     * Check if a given path (even a partial path) can contain things that
     * match the given matcher.
     *
     * Currently it can only look at the reftime part of the matcher.
     */
    virtual bool pathMatches(const std::string& path, const matcher::OR& m) const = 0;

    /**
     * List existing paths whose segments could intersect the reftime part of
     * the given matcher
     */
    virtual void list_segments(const step::SegmentQuery& query, std::function<void(std::string&&)> dest) const = 0;

    /**
     * Get the time span between the theoretical beginning of the first
     * available segment, and the theoretical end of the last available
     * segment.
     */
    virtual void time_extremes(const step::SegmentQuery& query, core::Interval& interval) const = 0;

    /**
     * Create a Step according to the given step type name.
     */
    static std::shared_ptr<Step> create(const std::string& type);

    /**
     * Return the list of available steps
     */
    static std::vector<std::string> list();
};

}
}
#endif
