#ifndef ARKI_DATASET_STEP_H
#define ARKI_DATASET_STEP_H

/// Compute names for segments in an arkimet dataset

#include <filesystem>
#include <string>
#include <vector>
#include <memory>
#include <functional>
#include "arki/core/fwd.h"
#include "arki/matcher.h"

namespace arki {
namespace dataset {
namespace step {

class Files;

/**
 * Parameters used to match segments
 */
struct SegmentQuery
{
    std::filesystem::path root;
    std::string format;
    std::string extension_re = "(\\.zip|\\.gz|\\.tar|)$";
    Matcher matcher;

    SegmentQuery();
    SegmentQuery(const std::filesystem::path& root, const std::string& format);
    SegmentQuery(const std::filesystem::path& root, const std::string& format, const Matcher& matcher);
    SegmentQuery(const std::filesystem::path& root, const std::string& format, const std::string& extension_re, const Matcher& matcher);
};

/**
 * Encapsulate a directory containing segment directories, and allow querying
 * them by date
 */
class Dirs
{
public:
    const SegmentQuery& query;

    Dirs(const SegmentQuery& query);
    virtual ~Dirs() {}

    /**
     * Generate all the matching file-containing directories under this one.
     */
    virtual void list(std::function<void(std::unique_ptr<Files>)> dest) const = 0;

    /**
     * Return the intervals of the first and last segment under this directory.
     */
    virtual void extremes(core::Interval& first, core::Interval& last) const = 0;
};

/**
 * Encapsulate a directory containing segments, and allow querying them by date
 */
class Files
{
protected:
    const Dirs& dirs;
    std::filesystem::path relpath;
    int value;

public:
    Files(const Dirs& dirs, const std::filesystem::path& relpath, int value);
    virtual ~Files() {}

    /**
     * List all matching segments in this directory, with paths relative to dirs.root
     */
    virtual void list(std::function<void(std::filesystem::path&& relpath)> dest) const = 0;

    /**
     * Return the first segment in this directory, with path relative to dirs.root
     */
    virtual core::Interval first() const = 0;

    /**
     * Return the last segment in this directory, with path relative to dirs.root
     */
    virtual core::Interval last() const = 0;
};

}

/**
 * Generator for filenames the dataset in which to store a metadata
 */
class Step
{
public:
    virtual ~Step() {}
    virtual std::filesystem::path operator()(const core::Time& time) const = 0;

    /**
     * Instantiate a step::Dirs to query segments for the given directory and format
     */
    virtual std::unique_ptr<step::Dirs> explore(const step::SegmentQuery& query) const = 0;

    /**
     * Get the timespan of a file by just looking at its path.
     *
     * Returns true if the path could be recognised, and false if it does not
     * look like path has been generated by this Step.
     */
    virtual bool path_timespan(const std::filesystem::path& path, core::Interval& interval) const = 0;

    /**
     * Check if a given path (even a partial path) can contain things that
     * match the given matcher.
     *
     * Currently it can only look at the reftime part of the matcher.
     */
    virtual bool pathMatches(const std::filesystem::path& path, const matcher::OR& m) const = 0;

    /**
     * List existing paths whose segments could intersect the reftime part of
     * the given matcher
     */
    virtual void list_segments(const step::SegmentQuery& query, std::function<void(std::filesystem::path&&)> dest) const = 0;

    /**
     * Get the time span between the theoretical beginning of the first
     * available segment, and the theoretical end of the last available
     * segment.
     */
    virtual void time_extremes(const step::SegmentQuery& query, core::Interval& interval) const = 0;

    /**
     * Create a Step according to the given step type name.
     */
    static std::shared_ptr<Step> create(const std::string& type);

    /**
     * Return the list of available steps
     */
    static std::vector<std::filesystem::path> list();
};

}
}
#endif
