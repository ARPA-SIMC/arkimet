#ifndef ARKI_DATASET_STEP_H
#define ARKI_DATASET_STEP_H

/// Compute names for segments in an arkimet dataset

#include <string>
#include <vector>
#include <memory>

namespace arki {

namespace utils {
struct Regexp;
}

namespace core {
class Time;
}

namespace types {
class Reftime;
namespace reftime {
class Period;
}
}

class Matcher;
namespace matcher {
class OR;
}

namespace dataset {

namespace step {

struct Files;

/**
 * Encapsulate a directory containing segment directories, and allow querying
 * them by date
 */
class Dirs
{
protected:
    const std::string& root;
    const std::string& format;

    virtual bool parse(const char* name, int& value) const = 0;
    virtual std::unique_ptr<types::reftime::Period> to_period(int value) const = 0;
    virtual std::unique_ptr<Files> make_files(const std::string& name, int value) const = 0;

public:
    Dirs(const std::string& root, const std::string& format);

    /**
     * Generate all the matching file-containing directories under this one.
     */
    void list(const Matcher& m, std::function<void(std::unique_ptr<Files>)> dest) const;

    /**
     * Return the Reftime periods of the first and last segment under this
     * directory.
     */
    void extremes(std::unique_ptr<types::reftime::Period>& first, std::unique_ptr<types::reftime::Period>& last) const;

    friend class Files;
};

/**
 * Encapsulate a directory containing segments, and allow querying them by date
 */
class Files
{
protected:
    const Dirs& dirs;
    std::string relpath;
    int value;

    virtual std::unique_ptr<utils::Regexp> make_regexp() const = 0;
    virtual std::unique_ptr<types::reftime::Period> to_period(const utils::Regexp& re) const = 0;

public:
    Files(const Dirs& dirs, const std::string& relpath, int value);

    /**
     * List all matching segments in this directory, with paths relative to dirs.root
     */
    void list(const Matcher& m, std::function<void(std::string&& relpath)> dest) const;

    /**
     * Return the first segment in this directory, with path relative to dirs.root
     */
    std::unique_ptr<types::reftime::Period> first() const;

    /**
     * Return the last segment in this directory, with path relative to dirs.root
     */
    std::unique_ptr<types::reftime::Period> last() const;
};

}

/**
 * Generator for filenames the dataset in which to store a metadata
 */
struct Step
{
    virtual ~Step() {}
    virtual std::string operator()(const core::Time& time) const = 0;

    /**
     * Instantiate a step::Dirs to query segments for the given directory and format
     */
    virtual std::unique_ptr<step::Dirs> explore(const std::string& root, const std::string& format) const = 0;

    /**
     * Get the timespan of a file by just looking at its path.
     *
     * Returns true if the path could be recognised, and false if it does not
     * look like path has been generated by this Step.
     */
    virtual bool path_timespan(const std::string& path, core::Time& start_time, core::Time& end_time) const = 0;

    /**
     * Check if a given path (even a partial path) can contain things that
     * match the given matcher.
     *
     * Currently it can only look at the reftime part of the matcher.
     */
    virtual bool pathMatches(const std::string& path, const matcher::OR& m) const = 0;

    /**
     * List existing paths whose segments could intersect the reftime part of
     * the given matcher
     */
    virtual void list_segments(const std::string& root, const std::string& format, const Matcher& m, std::function<void(std::string&&)> dest) const = 0;

    /**
     * Get the time span between the theoretical beginning of the first
     * available segment, and the theoretical end of the last available
     * segment.
     */
    virtual void time_extremes(const std::string& root, const std::string& format, std::unique_ptr<core::Time>& begin, std::unique_ptr<core::Time>& until) const = 0;

    /**
     * Create a Step according to the given step type name.
     */
    static std::shared_ptr<Step> create(const std::string& type);

    /**
     * Return the list of available steps
     */
    static std::vector<std::string> list();
};


/**
 * Generate paths from the root of sharded datasets.
 */
struct ShardStep
{
    virtual ~ShardStep() {}

    /// Return the path to the root of the sharded dataset for this datum
    virtual std::string shard_path(const core::Time& time) const = 0;

    /**
     * Return the Step to use for the dataset shard for a datum.
     *
     * The result of substep() is the same for all Metadata elements that
     * share the same shard_path()
     */
    virtual std::shared_ptr<Step> substep(const core::Time& time) const = 0;

    /**
     * Return the time bounds of a shard given its relative path.
     */
    virtual std::pair<core::Time, core::Time> shard_span(const std::string& shard_path) const = 0;

    /**
     * List all the shards inside a directory.
     *
     * @returns a sorted vector of Time entries of the start of the time range
     *          of each shard.
     */
    virtual std::vector<std::pair<core::Time, core::Time>> list_shards(const std::string& pathname) const = 0;

    /**
     * Create a Step according to the given step type name.
     */
    static std::shared_ptr<ShardStep> create(const std::string& shard_type, const std::string& type);
};

}
}
#endif
